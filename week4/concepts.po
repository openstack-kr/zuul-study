# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2026, Zuul project contributors
# This file is distributed under the same license as the Zuul package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Zuul latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-02 09:55+0900\n"
"PO-Revision-Date: 2026-02-12 10:55+0900\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko_KR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.8\n"

#: ../../source/concepts.rst:4
msgid "Zuul Concepts"
msgstr "Zuul 주요 개념"

#: ../../source/concepts.rst:6
msgid ""
"Zuul is organized around the concept of a *pipeline*.  In Zuul, a pipeline "
"encompasses a workflow process which can be applied to one or more "
"projects.  For instance, a \"check\" pipeline might describe the actions "
"which should cause newly proposed changes to projects to be tested.  A "
"\"gate\" pipeline might implement :ref:`project_gating` to automate merging "
"changes to projects only if their tests pass.  A \"post\" pipeline might "
"update published documentation for a project when changes land."
msgstr ""
"Zuul은 *파이프라인*이라는 개념을 중심으로 설계됩니다.  Zuul에서, 파이프라인"
"은 하나 이상의 프로젝트들에 적용될 수 있는 워크플로우 프로세스를 포함합니"
"다.  예시로, \"check\" 파이프라인은 프로젝트에 새로 제안된 변경 사항들을 테스"
"트하는 작업들을 정의할 수 있습니다  \"gate\" 파이프라인은 \":ref. "
"'projct_gating'을 구현하여 테스트를 통과한 경우에만 프로젝트에 변경 사항을 자"
"동으로 병합할 수 있습니다.  \"post\" 파이프라인은 변경 사항이 반영되었을 때 "
"프로젝트의 공개 문서를 갱신할 수 있습니다."

#: ../../source/concepts.rst:15
msgid ""
"The names \"check\", \"gate\", and \"post\" are arbitrary -- these are not "
"concepts built into Zuul, but rather they are just a few common examples of "
"workflow processes that can be described to Zuul and implemented as "
"pipelines."
msgstr ""
"\"check\", \"gate\", \"post\"라는 이름은 임의로 명명된 것입니다. -- 이 이름들"
"은 Zuul에 고정된 개념들이 아니라, Zuul에서 정의되고 파이프라인에서 구현될 수 "
"있는 워크플로우 프로세스들의 흔한 예시들일 뿐입니다."

#: ../../source/concepts.rst:20
msgid ""
"Once a pipeline has been defined, any number of projects may be associated "
"with it, each one specifying what jobs should be run for that project in a "
"given pipeline."
msgstr ""
"일단 파이프라인이 정의되면, 많은 프로젝트들을 해당 파이프라인에 연결할 수 있"
"으며, 프로젝트들은 각자 연결된 파이프라인에서 실행할 잡(job)을 정하게 됩니다."

#: ../../source/concepts.rst:24
msgid ""
"Pipelines have associated *triggers* which are descriptions of events which "
"should cause something to be enqueued into a pipeline.  For example, when a "
"patchset is uploaded to Gerrit, a Gerrit *patchset-created* event is "
"emitted.  A pipeline configured to trigger on *patchset-created* events "
"would then enqueue the associated change when Zuul receives that event.  If "
"there are jobs associated with that project and pipeline, they will be run.  "
"In addition to Gerrit, other triggers are available, including GitHub, "
"timer, and zuul.  See :ref:`drivers` for a full list of available triggers."
msgstr ""
"파이프라인에는 특정 이벤트들을 파이프라인 대기열에 넣도록 정의된 *트리거"
"(trigger)*가 연결되어 있습니다.  예를 들어, 패치셋을 Gerrit에 업로드할 때, "
"Gerrit *patchset-created* 이벤트가 발생됩니다.  *patchset-created* 이벤트 트"
"리거가 설정된 파이프라인은 Zuul이 그 이벤트를 수신할 때 관련 변경 사항을 대기"
"열에 넣습니다.  만약 해당 프로젝트와 파이프라인에 연결된 작업들이 있다면, 그 "
"작업들이 실행됩니다.  Gerrit 외에도 GitHub, 타이머, Zuul등 다른 트리거들을 사"
"용할 수 있습니다. 사용할 수 있는 트리거의 전체 목록은 :ref:'drivers'에 있습니"
"다."

#: ../../source/concepts.rst:34
msgid ""
"Once all of the jobs for an item in a pipeline have been run, the pipeline's "
"*reporters* are responsible for reporting the results of all of the jobs.  "
"Continuing the example from earlier, if a pipeline were configured with a "
"Gerrit reporter, it would leave a review comment on the change and set any "
"approval votes that are configured. There are several reporting phases "
"available; each of which may be configured with any number of reporters.  "
"See :ref:`drivers` for a full list of available reporters."
msgstr ""
"파이프라인에 있는 어느 아이템의 모든 작업들이 실행 완료되면, 해당 파이프라인"
"의 *리포터(reporter)*가 모든 작업의 결과를 보고하는 역할을 합니다.   앞선 예"
"시를 이어가자면, 파이프라인에 Gerrit 리포터가 설정된 경우, 리포터는 변경사항"
"에 리뷰 댓글을 남기고, 설정돤 승인 투표를 실행합니다.   리포팅 단계는 여러 단"
"계들로 이루어져 있고 각 단계마다 원하는 수의 리포터를 설정할 수 있습니다. 사"
"용 가능한 리포터들의 전체 목록은 :ref:`drivers`을 참조하세요."

#: ../../source/concepts.rst:43
msgid ""
"The items enqueued into a pipeline are each associated with a `git ref "
"<https://git-scm.com/book/en/v2/Git-Internals-Git-References>`_. That ref "
"may point to a proposed change, or it may be the tip of a branch or a tag.  "
"The triggering event determines the ref, and whether it represents a "
"proposed or merged commit.  Zuul prepares the ref for an item before running "
"jobs.  In the case of a proposed change, that means speculatively merging "
"the change into its target branch.  This means that any jobs that operate on "
"the change will run with the git repo in the state it will be in after the "
"change merges (which may be substantially different than the git repo state "
"of the change itself since the repo may have merged other changes since the "
"change was originally authored).  Items in a pipeline may depend on other "
"items, and if they do, all of their dependent changes will be included in "
"the git repo state that Zuul prepares.  Zuul attempts to maximize throughput "
"by running jobs for multiple changes in parallel.  Jobs may also specify "
"that they require additional git repos, and if so, the repo state (as of the "
"time when the item was enqueued in the pipeline) for those repos will also "
"be included.  For more detail on this process, "
"see :ref:`project_gating`, :ref:`dependencies`, and :ref:`global_repo_state`."
msgstr ""
"파이프라인 대기열에 들어가는 아이템은 각각 `git ref <https://git-scm.com/"
"book/en/v2/Git-Internals-Git-References>`_에 연결됩니다. 해당 ref는 제안된 변"
"경 사항을 가리키거나, 브랜치의 끝 혹은 태그를 나타낼 수도 있습니다. 트리거 이"
"벤트에 따라 해당 ref가 결정되며, 이것이 제안된 커밋인지 병합된 커밋인지도 결"
"정합니다. Zuul은 작업을 실행하기 전에 해당 아이템을 위한 ref를 준비합니다.  "
"제안된 변경 사항의 경우, 해당 변경사항을 대상 브렌치에 추측성으로 병합하는 것"
"을 의미합니다.  즉, 이는 변경 사항을 처리하는 모든 작업은 해당 변경 사항이 병"
"합 완료된 상태의 git 저장소에서 실행된다는 걸 의미합니다(변경사항이 처음 작성"
"된 시점 이후로 저장소에 다른 변경사항이 병합되었을 수 있으므로, 원래의 변경사"
"항 상태와 상당히 다를 수 있습니다 ).  파이프라인의 아이템들은 또 다른 아이템"
"에 의존할 수 있으며, 이 경우 Zuul이 준비한 git 저장소에 의존하는 모든 변경 사"
"항들이 포함됩니다.  Zuul은 여러 변경사항에 대한 작업을 병렬로 실행하여 처리량"
"을 극대화합니다.  작업은 추가 git 저장소를 요구할 수 있으며 이 경우, 그 저장"
"소 상태도(아이템의 파이프라인에 들어온 시점 기준) 포함됩니다.  이 과정의 상세"
"한 내용은 :ref:`project_gating`, :ref:`dependencies`,"
"와 :ref:`global_repo_state`.에 있습니다."

#: ../../source/concepts.rst:64
msgid ""
"The configuration for nearly everything described above is held in files "
"inside of the git repos upon which Zuul operates.  Zuul's configuration is "
"global, but distributed.  Jobs which are defined in one project might be "
"used in another project while pipelines are available to all projects.  When "
"Zuul starts, it reads its configuration from all of the projects it knows "
"about, and when changes to its configuration are proposed, those changes may "
"take effect temporarily as part of the proposed change, or immediately after "
"the change merges, depending on the type of project in which the change "
"appears."
msgstr ""
"위에서 설명한 거의 모든 설정은 Zuul이 관리하는 git 저장소 내부 파일에 저장되"
"어 있습니다.  Zuul의 설정은 전역적인 동시에 분산되어 있습니다.  한 프로젝트에"
"서 정의된 작업은 다른 프로젝트에서 사용될 수 있으며, 파이프라인은 모든 프로젝"
"트에서 사용가능 합니다.  Zuul은 시작될 때, 자신이 알고 있는 모든 프로젝트들"
"의 설정을 읽습니다. 그리고, 그 설정의 변경사항이 제안될 때, 프로젝트의 유형"
"에 따라 해당 변경사항을 검증하는 동안만 임시로 적용되거나 병합된 후 즉시 반영"
"됩니다."

#: ../../source/concepts.rst:75
msgid ""
"Jobs specify the type and quantity of nodes which they require.  Zuul may be "
"configured to supply static nodes or contact cloud providers to create or "
"delete nodes as necessary."
msgstr ""
"잡(job)은 자신이 필요한 노드의 타입과 개수를 명시합니다.  Zuul은 정적 노드를 "
"제공하거나 필요에 따라 노드를 생성, 삭제하기 위해 클라우드 제공자와 통신하도"
"록 설정될 수 있습니다."

#: ../../source/concepts.rst:79
msgid ""
"The executable contents of jobs themselves are Ansible playbooks. Ansible's "
"support for orchestrating tasks on remote nodes is particularly suited to "
"Zuul's support for multi-node testing.  Ansible is also easy to use for "
"simple tasks (such as executing a shell script) or sophisticated deployment "
"scenarios.  When Zuul runs Ansible, it attempts to do so in a manner most "
"similar to the way that Ansible might be used to orchestrate remote "
"systems.  Ansible itself is run on the :ref:`executor <executor>` and acts "
"remotely upon the test nodes supplied to a job.  This facilitates continuous "
"delivery by making it possible to use the same Ansible playbooks in testing "
"and production."
msgstr ""
"잡(job)에서 실행되는 내용은 Ansible 플레이북입니다. 원격 노드에서 작업을 조율"
"하는 Ansible의 방식은 특히 Zuul의 멀티 노드 테스팅 지원에 적합합니다.  또한 "
"Ansible은 쉘 스크립트 실행 같은 간단한 일부터 복잡한 배포 시나리오에 사용하"
"기 쉽습니다. Zuul이 Ansible을 실행할 때, Zuul은 Ansible이 원격 시스템을 조율"
"하는 방식과 비슷하게 하려고 시도합니다.  Ansible 그자체는 :ref:`executor "
"<executor>에서 실행되며, 잡(job)에 할당된 테스트 노드에 대해 원격으로 동작합"
"니다.  이는 테스트와 운영환경에서 동일한 Ansible 플레이북을 사용하는 것을 가"
"능하게 함으로써 지속적 인도를 용이하게 합니다."
