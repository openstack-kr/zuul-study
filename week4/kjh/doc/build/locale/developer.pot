# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2026, Zuul project contributors
# This file is distributed under the same license as the Zuul package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Zuul latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-09 11:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/developer/ansible.rst:2
msgid "Ansible Integration"
msgstr ""

#: ../../source/developer/ansible.rst:4
msgid "Zuul contains Ansible modules and plugins to control the execution of Ansible Job content."
msgstr ""

#: ../../source/developer/ansible.rst:7
msgid "Zuul provides realtime build log streaming to end users so that users can watch long-running jobs in progress."
msgstr ""

#: ../../source/developer/ansible.rst:11
msgid "Streaming job output"
msgstr ""

#: ../../source/developer/ansible.rst:13
msgid "All jobs run with the :py:mod:`zuul.ansible.base.callback.zuul_stream` callback plugin enabled, which writes the build log to a file so that the :py:class:`zuul.lib.log_streamer.LogStreamer` can provide the data on demand over the finger protocol. Finally, :py:class:`zuul.web.LogStreamHandler` exposes that log stream over a websocket connection as part of :py:class:`zuul.web.ZuulWeb`."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/ansible/base/callback/zuul_stream.py:docstring of zuul.ansible.base.callback.zuul_stream.CallbackModule:1
msgid "This is the Zuul streaming callback. It's based on the default callback plugin, but streams results from shell commands."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/lib/log_streamer.py:docstring of zuul.lib.log_streamer.LogStreamer:1
msgid "Class implementing log streaming over the finger daemon port."
msgstr ""

#: ../../source/developer/ansible.rst:25
msgid "In addition to real-time streaming, Zuul also installs another callback module, :py:mod:`zuul.ansible.base.callback.zuul_json.CallbackModule` that collects all of the information about a given run into a json file which is written to the work dir so that it can be published along with build logs."
msgstr ""

#: ../../source/developer/ansible.rst:32
msgid "Since the streaming log is by necessity a single text stream, choices have to be made for readability about what data is shown and what is not shown. The json log file is intended to allow for a richer more interactive set of data to be displayed to the user."
msgstr ""

#: ../../source/developer/ansible.rst:40
msgid "Capturing live command output"
msgstr ""

#: ../../source/developer/ansible.rst:42
msgid "As jobs may execute long-running shell scripts or other commands, additional effort is expended to stream ``stdout`` and ``stderr`` of shell tasks as they happen rather than waiting for the command to finish."
msgstr ""

#: ../../source/developer/ansible.rst:47
msgid "The global job configuration should run the ``zuul_console`` task as a very early prerequisite step."
msgstr ""

#: ../../source/developer/ansible.rst:52
msgid "This will start a daemon that listens on TCP port 19885 on the testing node.  This daemon can be queried to stream back the output of shell tasks as described below."
msgstr ""

#: ../../source/developer/ansible.rst:56
msgid "Zuul contains a modified version of Ansible's :ansible:module:`command` module that overrides the default implementation."
msgstr ""

#: ../../source/developer/ansible.rst:62
msgid "This library will capture the output of the running command and write it to a temporary file on the host the command is running on.  These files are named in the format ``/tmp/console-<uuid>-<task_id>-<host>.log``"
msgstr ""

#: ../../source/developer/ansible.rst:67
msgid "The ``zuul_stream`` callback mentioned above will send a request to the remote ``zuul_console`` daemon, providing the uuid and task id of the task it is currently processing.  The ``zuul_console`` daemon will then read the logfile from disk and stream the data back as it appears, which ``zuul_stream`` will then present as described above."
msgstr ""

#: ../../source/developer/ansible.rst:73
msgid "The ``zuul_stream`` callback will indicate to the ``zuul_console`` daemon when it has finished reading the task, which prompts the remote side to remove the temporary streaming output files.  In some cases, aborting the Ansible process may not give the ``zuul_stream`` callback the chance to send this notice, leaking the temporary files.  If nodes are ephemeral this makes little difference, but these files may be visible on static nodes."
msgstr ""

#: ../../source/developer/datamodel.rst:2
msgid "Data Model"
msgstr ""

#: ../../source/developer/datamodel.rst:4
msgid "It all starts with the :py:class:`~zuul.model.Pipeline`. A Pipeline is the basic organizational structure that everything else hangs off."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Pipeline:1
msgid "A configuration that ties together triggers, reporters and managers"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Pipeline:3
msgid "Trigger"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Pipeline:4
msgid "A description of which events should be processed"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Pipeline:6
msgid "Manager"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Pipeline:7
msgid "Responsible for enqueing and dequeing Changes"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Pipeline:9
msgid "Reporter"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Pipeline:10
msgid "Communicates success and failure results somewhere"
msgstr ""

#: ../../source/developer/datamodel.rst:9
msgid "Pipelines have a configured :py:class:`~zuul.manager.PipelineManager` which controls how the :py:class:`Ref <zuul.model.Ref>` objects are enqueued and processed."
msgstr ""

#: ../../source/developer/datamodel.rst:14
msgid "There are currently two, :py:class:`~zuul.manager.dependent.DependentPipelineManager` and :py:class:`~zuul.manager.independent.IndependentPipelineManager`"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/manager/__init__.py:docstring of zuul.manager.PipelineManager:1
msgid "Abstract Base Class for enqueing and processing Changes in a Pipeline"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/manager/dependent.py:docstring of zuul.manager.dependent.DependentPipelineManager:1
msgid "PipelineManager for handling interrelated Changes."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/manager/dependent.py:docstring of zuul.manager.dependent.DependentPipelineManager:3
msgid "The DependentPipelineManager puts Changes that share a Pipeline into a shared :py:class:`~zuul.model.ChangeQueue`. It then processes them using the Optimistic Branch Prediction logic with Nearest Non-Failing Item reparenting algorithm for handling errors."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/manager/independent.py:docstring of zuul.manager.independent.IndependentPipelineManager:1
msgid "PipelineManager that puts every Change into its own ChangeQueue."
msgstr ""

#: ../../source/developer/datamodel.rst:22
msgid "A :py:class:`~zuul.model.Pipeline` has one or more :py:class:`~zuul.model.ChangeQueue` objects."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.ChangeQueue:1
msgid "A ChangeQueue contains Changes to be processed for related projects."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.ChangeQueue:3
msgid "A Pipeline with a DependentPipelineManager has multiple parallel ChangeQueues shared by different projects. For instance, there may a ChangeQueue shared by interrelated projects foo and bar, and a second queue for independent project baz."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.ChangeQueue:8
msgid "A Pipeline with an IndependentPipelineManager puts every Change into its own ChangeQueue."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.ChangeQueue:11
msgid "The ChangeQueue Window is inspired by TCP windows and controlls how many Changes in a given ChangeQueue will be considered active and ready to be processed. If a Change succeeds, the Window is increased by `window_increase_factor`. If a Change fails, the Window is decreased by `window_decrease_factor`."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.ChangeQueue:17
msgid "A ChangeQueue may be a dynamically created queue, which may be removed from a DependentPipelineManager once empty."
msgstr ""

#: ../../source/developer/datamodel.rst:27
msgid "A :py:class:`~zuul.model.Job` represents the definition of what to do. A :py:class:`~zuul.model.Build` represents a single run of a :py:class:`~zuul.model.Job`. A :py:class:`~zuul.model.JobGraph` is used to encapsulate the dependencies between one or more :py:class:`~zuul.model.Job` objects."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Job:1
msgid "A Job represents the defintion of actions to perform."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Job:3
msgid "A Job is an abstract configuration concept.  It describes what, where, and under what circumstances something should be run (contrast this with Build which is a concrete single execution of a Job)."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Job:8
msgid "NB: Do not modify attributes of this class, set them directly (e.g., \"job.run = ...\" rather than \"job.run.append(...)\")."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.JobGraph:1
msgid "A JobGraph represents the dependency graph between Jobs."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.JobGraph:3
msgid "This class is an attribute of the BuildSet, and should not be modified after its initial creation."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Build:1
msgid "A Build is an instance of a single execution of a Job."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Build:3
msgid "While a Job describes what to run, a Build describes an actual execution of that Job.  Each build is associated with exactly one Job (related builds are grouped together in a BuildSet)."
msgstr ""

#: ../../source/developer/datamodel.rst:37
msgid "The :py:class:`~zuul.manager.base.PipelineManager` enqueues each :py:class:`Ref <zuul.model.Ref>` into the :py:class:`~zuul.model.ChangeQueue` in a :py:class:`~zuul.model.QueueItem`."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.QueueItem:1
msgid "Represents the position of a Change in a ChangeQueue."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.QueueItem:3
msgid "All Changes are enqueued into ChangeQueue in a QueueItem. The QueueItem holds the current `BuildSet` as well as all previous `BuildSets` that were produced for this `QueueItem`."
msgstr ""

#: ../../source/developer/datamodel.rst:43
msgid "As the Changes are processed, each :py:class:`~zuul.model.Build` is put into a :py:class:`~zuul.model.BuildSet`"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.BuildSet:1
msgid "A collection of Builds for one specific potential future repository state."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.BuildSet:4
msgid "When Zuul executes Builds for a change, it creates a Build to represent each execution of each job and a BuildSet to keep track of all the Builds running for that Change.  When Zuul re-executes Builds for a Change with a different configuration, all of the running Builds in the BuildSet for that change are aborted, and a new BuildSet is created to hold the Builds for the Jobs being run with the new configuration."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.BuildSet:12
msgid "A BuildSet also holds the UUID used to produce the Zuul Ref that builders check out."
msgstr ""

#: ../../source/developer/datamodel.rst:49
msgid "Changes"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Change:1
msgid "A proposed new state for a Project."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Ref:1
msgid "An existing state of a Project."
msgstr ""

#: ../../source/developer/datamodel.rst:55
msgid "Filters"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.RefFilter:1
msgid "Allows a Manager to only enqueue Changes that meet certain criteria."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.EventFilter:1
msgid "Allows a Pipeline to only respond to certain events."
msgstr ""

#: ../../source/developer/datamodel.rst:62
msgid "Tenants"
msgstr ""

#: ../../source/developer/datamodel.rst:64
msgid "An abide is a collection of tenants."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.UnparsedAbideConfig:1
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.UnparsedConfig:1
msgid "A collection of yaml lists that has not yet been parsed into objects."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.UnparsedAbideConfig:3
msgid "An Abide is a collection of tenants and access rules to those tenants."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.ParsedConfig:1
msgid "A collection of parsed config objects."
msgstr ""

#: ../../source/developer/datamodel.rst:72
msgid "Other Global Objects"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Project:1
msgid "A Project represents a git repository such as openstack/nova."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.Layout:1
msgid "Holds all of the Pipelines."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.RepoFiles:1
msgid "RepoFiles holds config-file content for per-project job config."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.RepoFiles:3
msgid "When Zuul asks a merger to prepare a future multiple-repo state and collect Zuul configuration files so that we can dynamically load our configuration, this class provides cached access to that data for use by the Change which updated the config files and any changes that follow it in a ChangeQueue."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.RepoFiles:9
msgid "It is attached to a BuildSet since the content of Zuul configuration files can change with each new BuildSet."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/model.py:docstring of zuul.model.TriggerEvent:1
msgid "Incoming event from an external system."
msgstr ""

#: ../../source/developer/docs.rst:2
msgid "Documentation"
msgstr ""

#: ../../source/developer/docs.rst:4
msgid "This is a brief style guide for Zuul documentation."
msgstr ""

#: ../../source/developer/docs.rst:7
msgid "ReStructuredText Conventions"
msgstr ""

#: ../../source/developer/docs.rst:10
msgid "Code Blocks"
msgstr ""

#: ../../source/developer/docs.rst:12
msgid "When showing a YAML example, use the ``.. code-block:: yaml`` directive so that the sample appears as a code block with the correct syntax highlighting."
msgstr ""

#: ../../source/developer/docs.rst:17
msgid "Literal Values"
msgstr ""

#: ../../source/developer/docs.rst:19
msgid "Filenames and literal values (such as when we instruct a user to type a specific string into a configuration file) should use the RST ````literal```` syntax."
msgstr ""

#: ../../source/developer/docs.rst:23
msgid "YAML supports boolean values expressed with or without an initial capital letter.  In examples and documentation, use ``true`` and ``false`` in lowercase type because the resulting YAML is easier for users to type and read."
msgstr ""

#: ../../source/developer/docs.rst:29
msgid "Terminology"
msgstr ""

#: ../../source/developer/docs.rst:31
msgid "Zuul employs some specialized terminology.  To help users become acquainted with it, we employ a glossary.  Observe the following:"
msgstr ""

#: ../../source/developer/docs.rst:34
msgid "Specialized terms should have entries in the glossary."
msgstr ""

#: ../../source/developer/docs.rst:36
msgid "If the term is being defined in the text, don't link to the glossary (that would be redundant), but do emphasize it with ``*italics*`` the first time it appears in that definition.  Subsequent uses within the same subsection should be in regular type."
msgstr ""

#: ../../source/developer/docs.rst:41
msgid "If it's being used (but not defined) in the text, link the first usage within a subsection to the glossary using the ``:term:`` role, but subsequent uses should be in regular type."
msgstr ""

#: ../../source/developer/docs.rst:45
msgid "Be cognizant of how readers may jump to link targets within the text, so be liberal in considering that once you cross a link target, you may be in a new \"subsection\" for the above guideline."
msgstr ""

#: ../../source/developer/docs.rst:51
msgid "Zuul Sphinx Directives"
msgstr ""

#: ../../source/developer/docs.rst:53
msgid "The following extra Sphinx directives are available in the ``zuul`` domain.  The ``zuul`` domain is configured as the default domain, so the ``zuul:`` prefix may be omitted."
msgstr ""

#: ../../source/developer/docs.rst:58
msgid "zuul:attr::"
msgstr ""

#: ../../source/developer/docs.rst:60
msgid "This should be used when documenting Zuul configuration attributes. Zuul configuration is heavily hierarchical, and this directive facilitates documenting these by emphasising the hierarchy as appropriate.  It will annotate each configuration attribute with a nice header with its own unique hyperlink target.  It displays the entire hierarchy of the attribute, but emphasises the last portion (i.e., the field being documented)."
msgstr ""

#: ../../source/developer/docs.rst:68
msgid "To use the hierarchical features, simply nest with indentation in the normal RST manner."
msgstr ""

#: ../../source/developer/docs.rst:71
msgid "It supports the ``required`` and ``default`` options and will annotate the header appropriately.  Example:"
msgstr ""

#: ../../source/developer/docs.rst:89
msgid "Some text about ``foo``."
msgstr ""

#: ../../source/developer/docs.rst:96
msgid "Text about ``foo.bar``."
msgstr ""

#: ../../source/developer/docs.rst:99
msgid "zuul:value::"
msgstr ""

#: ../../source/developer/docs.rst:101
msgid "Similar to zuul:attr, but used when documenting a literal value of an attribute."
msgstr ""

#: ../../source/developer/docs.rst:121
msgid "Some text about foo.  It supports the following values:"
msgstr ""

#: ../../source/developer/docs.rst:126
msgid "One of the supported values for ``foo`` is ``bar``."
msgstr ""

#: ../../source/developer/docs.rst:131
msgid "Another supported values for ``foo`` is ``baz``."
msgstr ""

#: ../../source/developer/docs.rst:134
msgid "zuul:var::"
msgstr ""

#: ../../source/developer/docs.rst:136
msgid "Also similar to zuul:attr, but used when documenting an Ansible variable which is available to a job's playbook.  In these cases, it's often necessary to indicate the variable may be an element of a list or dictionary, so this directive supports a ``type`` option.  It also supports the ``hidden`` option so that complex data structure definitions may continue across sections.  To use this, set the hidden option on a ``zuul:var::`` directive with the root of the data structure as the name.  Example:"
msgstr ""

#: ../../source/developer/docs.rst:174
msgid "Foo is a dictionary with the following keys:"
msgstr ""

#: ../../source/developer/docs.rst:180
msgid "Items is a list of dictionaries with the following keys:"
msgstr ""

#: ../../source/developer/docs.rst:185
msgid "Text about bar"
msgstr ""

#: ../../source/developer/docs.rst:187
msgid "Section Boundary"
msgstr ""

#: ../../source/developer/docs.rst:196
msgid "Text about baz"
msgstr ""

#: ../../source/developer/docs.rst:201
msgid "Zuul Sphinx Roles"
msgstr ""

#: ../../source/developer/docs.rst:203
msgid "The following extra Sphinx roles are available.  Use these within the text when referring to attributes, values, and variables defined with the directives above.  Use these roles for the first appearance of an object within a subsection, but use the ````literal```` role in subsequent uses."
msgstr ""

#: ../../source/developer/docs.rst:210
msgid "\\:zuul:attr:"
msgstr ""

#: ../../source/developer/docs.rst:212
msgid "This creates a reference to the named attribute.  Provide the fully qualified name (e.g., ``:attr:`pipeline.manager```)"
msgstr ""

#: ../../source/developer/docs.rst:216
msgid "\\:zuul:value:"
msgstr ""

#: ../../source/developer/docs.rst:218
msgid "This creates a reference to the named value.  Provide the fully qualified name (e.g., ``:attr:`pipeline.manager.dependent```)"
msgstr ""

#: ../../source/developer/docs.rst:222
msgid "\\:zuul:var:"
msgstr ""

#: ../../source/developer/docs.rst:224
msgid "This creates a reference to the named variable.  Provide the fully qualified name (e.g., ``:var:`zuul.executor.name```)"
msgstr ""

#: ../../source/developer/drivers.rst:2
msgid "Drivers"
msgstr ""

#: ../../source/developer/drivers.rst:4
msgid "Zuul provides an API for extending its functionality to interact with other systems."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver:1
msgid "A Driver is an extension component of Zuul that supports interfacing with a remote system.  It can support any of the following interfaces (but must support at least one to be useful):"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver:5
msgid "ConnectionInterface"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver:6
msgid "SourceInterface"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver:7
msgid "TriggerInterface"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver:8
msgid "ReporterInterface"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver:10
msgid "Zuul will create a single instance of each Driver (which will be shared by all tenants), and this instance will persist for the life of the process.  The Driver class may therefore manage any global state used by all connections."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver:15
msgid "The class or instance attribute **name** must be provided as a string."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.reconfigure:1
msgid "Called when a tenant is reconfigured."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.reconfigure:3
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.registerScheduler:3
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.stop:3
msgid "This method is optional; the base implementation does nothing."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.reconfigure:5
msgid "When Zuul performs a reconfiguration for a tenant, this method is called with the tenant (including the new layout configuration) as an argument.  The driver may establish any global resources needed by the tenant at this point."
msgstr ""

#: ../../source/developer/drivers.rst:0
#: ../../source/developer/testing.rst:0
#: ../../../tests/base.py:docstring of tests.base.simple_layout:0
msgid "Parameters"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.reconfigure:10
msgid "The :py:class:`zuul.model.Tenant` which has been reconfigured."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.registerScheduler:1
msgid "Register the scheduler with the driver."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.registerScheduler:5
msgid "This method is called once during initialization to allow the driver to store a handle to the running scheduler."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.registerScheduler:8
msgid "The current running :py:class:`zuul.scheduler.Scheduler`."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.stop:1
msgid "Stop the driver from running."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.Driver.stop:5
msgid "This method is called when the connection registry is stopped allowing you additionally stop any running Driver computation not specific to a connection."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ConnectionInterface:1
msgid "The Connection interface."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ConnectionInterface:3
msgid "A driver which is able to supply a Connection should implement this interface."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ConnectionInterface.getConnection:1
msgid "Create and return a new Connection object."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ConnectionInterface.getConnection:3
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporter:3
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporterSchema:3
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getRejectSchema:3
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getRequireSchema:3
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getSource:3
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTrigger:3
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTriggerSchema:3
msgid "This method is required by the interface."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ConnectionInterface.getConnection:5
msgid "This method will be called once for each connection specified in zuul.conf.  The resultant object should be responsible for establishing any long-lived connections to remote systems.  If Zuul is reconfigured, all existing connections will be stopped and this method will be called again for any new connections which should be created."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ConnectionInterface.getConnection:12
msgid "When a connection is specified in zuul.conf with a name, that name is used here when creating the connection, and it is also used in the layout to attach triggers and reporters to the named connection.  If the Driver does not utilize a connection (because it does not interact with a remote system), do not implement this method and Zuul will automatically associate triggers and reporters with the name of the Driver itself where it would normally expect the name of a connection."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ConnectionInterface.getConnection:21
msgid "The name of the connection.  This is the name supplied in the zuul.conf file where the connection is configured."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ConnectionInterface.getConnection:24
msgid "The configuration information supplied along with the connection in zuul.conf."
msgstr ""

#: ../../source/developer/drivers.rst:0
#: ../../source/developer/testing.rst:0
msgid "Returns"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ConnectionInterface.getConnection:27
msgid "A new Connection object."
msgstr ""

#: ../../source/developer/drivers.rst:0
#: ../../source/developer/testing.rst:0
msgid "Return type"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface:1
msgid "The source interface to be implemented by a driver."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface:3
msgid "A driver which is able to supply a Source should implement this interface."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getRejectSchema:1
msgid "Get the schema for this driver's pipeline reject filter."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporterSchema:5
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getRejectSchema:5
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getRequireSchema:5
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTriggerSchema:5
msgid "A voluptuous schema."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getRequireSchema:1
msgid "Get the schema for this driver's pipeline requirement filter."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getSource:1
msgid "Create and return a new Source object."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getSource:5
msgid "The Connection object associated with the source (as previously returned by getConnection)."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.SourceInterface.getSource:8
msgid "A new Source object."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface:1
msgid "The trigger interface."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface:3
msgid "A driver which is able to supply a trigger should implement this interface."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTrigger:1
msgid "Create and return a new trigger object."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTrigger:5
msgid "The trigger object returned should inherit from the :py:class:`~zuul.trigger.BaseTrigger` class."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTrigger:8
msgid "The Connection object associated with the trigger (as previously returned by getConnection) or None."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTrigger:11
msgid "The configuration information supplied along with the trigger in the layout."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTrigger:14
msgid "A new trigger object."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTrigger:15
msgid ":py:class:`~zuul.trigger.BaseTrigger`"
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTriggerEventClass:1
msgid "Get the drivers's trigger event class."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.TriggerInterface.getTriggerSchema:1
msgid "Get the schema for this driver's trigger."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface:1
msgid "The reporter interface to be implemented by a driver."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface:3
msgid "A driver which is able to supply a Reporter should implement this interface."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporter:1
msgid "Create and return a new Reporter object."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporter:5
msgid "The Connection object associated with the reporter (as previously returned by getConnection) or None."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporter:8
msgid "The pipeline object associated with the reporter."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporter:10
msgid "The configuration information supplied along with the reporter in the layout."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporter:12
msgid "The parse context during config loading."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporter:15
msgid "A new Reporter object."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/__init__.py:docstring of zuul.driver.ReporterInterface.getReporterSchema:1
msgid "Get the schema for this driver's reporter."
msgstr ""

#: ../../source/developer/index.rst:2
msgid "Developer's Guide"
msgstr ""

#: ../../source/developer/index.rst:4
msgid "This section contains information for Developers who wish to work on Zuul itself.  This information is not necessary for the operation of Zuul, though advanced users may find it interesting."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/scheduler.py:docstring of zuul.scheduler.Scheduler:1
msgid "The engine of Zuul."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/scheduler.py:docstring of zuul.scheduler.Scheduler:3
msgid "The Scheduler is responsible for receiving events and dispatching them to appropriate components (including pipeline managers, mergers and executors)."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/scheduler.py:docstring of zuul.scheduler.Scheduler:7
msgid "It runs a single threaded main loop which processes events received one at a time and takes action as appropriate.  Other parts of Zuul may run in their own thread, but synchronization is performed within the scheduler to reduce or eliminate the need for locking in most circumstances."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/scheduler.py:docstring of zuul.scheduler.Scheduler:13
msgid "The main daemon will have one instance of the Scheduler class running which will persist for the life of the process.  The Scheduler instance is supplied to other Zuul components so that they can submit events or otherwise communicate with other components."
msgstr ""

#: ../../source/developer/javascript.rst:2
msgid "Zuul Dashboard Javascript"
msgstr ""

#: ../../source/developer/javascript.rst:4
msgid "zuul-web has an html, css and javascript component, `zuul-dashboard`, that is managed using Javascript toolchains. It is intended to be served by zuul-web directly from zuul/web/static in the simple case, or to be published to an alternate static web location, such as an Apache server."
msgstr ""

#: ../../source/developer/javascript.rst:9
msgid "The web dashboard is written in `React`_ and `PatternFly`_ and is managed by `create-react-app`_ and `yarn`_ which in turn both assume a functioning and recent `nodejs`_ installation."
msgstr ""

#: ../../source/developer/javascript.rst:15
msgid "The web dashboard source code and package.json are located in the ``web`` directory. All the yarn commands need to be executed from the ``web`` directory."
msgstr ""

#: ../../source/developer/javascript.rst:20
msgid "For the impatient who don't want deal with javascript toolchains"
msgstr ""

#: ../../source/developer/javascript.rst:22
msgid "tl;dr - You have to build stuff with javascript tools."
msgstr ""

#: ../../source/developer/javascript.rst:24
msgid "The best thing would be to get familiar with the tools, there are a lot of good features available. If you're going to hack on the Javascript, you should get to know them."
msgstr ""

#: ../../source/developer/javascript.rst:28
msgid "If you don't want to hack on Javascript and just want to run Zuul's tests, ``nox`` has been set up to handle it for you."
msgstr ""

#: ../../source/developer/javascript.rst:31
msgid "If you do not have `yarn`_ installed, ``nox`` will use `nodeenv`_ to install node into the active python virtualenv, and then will install `yarn`_ into that virtualenv as well."
msgstr ""

#: ../../source/developer/javascript.rst:36
msgid "yarn dependency management"
msgstr ""

#: ../../source/developer/javascript.rst:38
msgid "`yarn`_ manages the javascript dependencies. That means the first step is getting `yarn`_ installed."
msgstr ""

#: ../../source/developer/javascript.rst:45
msgid "The ``tools/install-js-tools.sh`` script will add apt or yum repositories and install `nodejs`_ and `yarn`_ from them. For RPM-based distros it needs to know which repo description file to download, so it calls out to ``tools/install-js-repos-rpm.sh``."
msgstr ""

#: ../../source/developer/javascript.rst:50
msgid "Once yarn is installed, getting dependencies installed is:"
msgstr ""

#: ../../source/developer/javascript.rst:56
msgid "The ``yarn.lock`` file contains all of the specific versions that were installed before. Since this is an application it has been added to the repo."
msgstr ""

#: ../../source/developer/javascript.rst:59
msgid "To add new runtime dependencies:"
msgstr ""

#: ../../source/developer/javascript.rst:65
msgid "To add new build-time dependencies:"
msgstr ""

#: ../../source/developer/javascript.rst:71
msgid "To remove dependencies:"
msgstr ""

#: ../../source/developer/javascript.rst:77
msgid "Adding or removing packages will add the logical dependency to ``package.json`` and will record the version of the package and any of its dependencies that were installed into ``yarn.lock`` so that other users can simply run ``yarn install`` and get the same environment."
msgstr ""

#: ../../source/developer/javascript.rst:82
msgid "To update a dependency:"
msgstr ""

#: ../../source/developer/javascript.rst:88
msgid "Dependencies are installed into the ``node_modules`` directory. Deleting that directory and re-running ``yarn install`` should always be safe."
msgstr ""

#: ../../source/developer/javascript.rst:92
msgid "Dealing with yarn.lock merge conflicts"
msgstr ""

#: ../../source/developer/javascript.rst:94
msgid "Since ``yarn.lock`` is generated, it can create merge conflicts. Resolving them at the ``yarn.lock`` level is too hard, but `yarn`_ itself is deterministic. The best procedure for dealing with ``yarn.lock`` merge conflicts is to first resolve the conflicts, if any, in ``package.json``. Then:"
msgstr ""

#: ../../source/developer/javascript.rst:104
msgid "Which causes yarn to discard the ``yarn.lock`` file, recalculate the dependencies and write new content."
msgstr ""

#: ../../source/developer/javascript.rst:108
msgid "React Components and Styling"
msgstr ""

#: ../../source/developer/javascript.rst:110
msgid "Each page is a React Component. For instance the status.html page code is ``web/src/pages/status.jsx``. It is usually a good idea not to put too much markup in those page components and create different components for this instead. This way, the page component can deal with the logic like reloading data if needed or evaluating URL parameters and the child components can deal with the markup.  Thus, you will find a lot of components in the ``web/src/containers`` directory that mainly deal with the markup."
msgstr ""

#: ../../source/developer/javascript.rst:119
msgid "Mapping of pages/urls to components can be found in the route list in ``web/src/routes.js``."
msgstr ""

#: ../../source/developer/javascript.rst:122
msgid "The best way to get started is to check out the libraries that glue everything together. Those are `React`__, `react-router`_ and `Redux`_."
msgstr ""

#: ../../source/developer/javascript.rst:130
msgid "For the visual part we are using `PatternFly`_. For a list of available PatternFly React components, take a look at the `Components`_ section in their documentation. If a single component is not enough, you could also take a look at the `Demos`_ sections which provides some more advanced examples incorporating multiple components and their interaction."
msgstr ""

#: ../../source/developer/javascript.rst:136
msgid "If you are unsure which component you should use for your purpose, you might want to check out the `Usage and behaviour`_ section in their design guidelines."
msgstr ""

#: ../../source/developer/javascript.rst:139
msgid "There is also a list of available `icons`_ including some recommendations on when to use which icon. In case you don't find an appropriate icon there, you could check out the `FontAwesome Free`_ icons, as most of them are included in PatternFly. To find out if an icon is available, simply try to import it from the ``@patternfly/react-icons`` package."
msgstr ""

#: ../../source/developer/javascript.rst:145
msgid "For example if you want to use the `address-book`_ icon (which is not listed in the PatternFly icon list) you can import it via the following statement:"
msgstr ""

#: ../../source/developer/javascript.rst:152
msgid "Please note that the spelling of the icon name changes to CamelCase and is always extended by ``Icon``."
msgstr ""

#: ../../source/developer/javascript.rst:156
msgid "Development"
msgstr ""

#: ../../source/developer/javascript.rst:158
msgid "Building the code can be done with:"
msgstr ""

#: ../../source/developer/javascript.rst:164
msgid "zuul-web has a ``static`` route defined which serves files from ``zuul/web/static``. ``yarn build`` will put the build output files into the ``zuul/web/static`` directory so that zuul-web can serve them."
msgstr ""

#: ../../source/developer/javascript.rst:168
msgid "Development server that handles things like reloading and hot-updating of code can be started with:"
msgstr ""

#: ../../source/developer/javascript.rst:175
msgid "will build the code and launch the dev server on `localhost:3000`. Fake api response needs to be set in the ``web/public/api`` directory."
msgstr ""

#: ../../source/developer/javascript.rst:185
msgid "To use an existing zuul api, uses the REACT_APP_ZUUL_API environment variable:"
msgstr ""

#: ../../source/developer/javascript.rst:199
msgid "To run eslint tests locally:"
msgstr ""

#: ../../source/developer/javascript.rst:206
msgid "Authentication"
msgstr ""

#: ../../source/developer/javascript.rst:208
msgid "The docker-compose file in ``doc/source/examples/keycloak`` can be used to run a Keycloak server for use with a development build of the web app.  The default values in that file are already set up for the web app running on localhost.  See the Keycloak tutorial for details."
msgstr ""

#: ../../source/developer/javascript.rst:215
msgid "Deploying"
msgstr ""

#: ../../source/developer/javascript.rst:217
msgid "The web application is a set of static files and is designed to be served by zuul-web from its ``static`` route. In order to make sure this works properly, the javascript build needs to be performed so that the javascript files are in the ``zuul/web/static`` directory. Because the javascript build outputs into the ``zuul/web/static`` directory, as long as ``yarn build`` has been done before ``pip install .`` or ``python setup.py sdist``, all the files will be where they need to be. As long as `yarn`_ is installed, the installation of zuul will run ``yarn build`` appropriately."
msgstr ""

#: ../../source/developer/javascript.rst:244
msgid "By default, zuul-web provides a Progressive Web Application but does not run a Service Worker. For deployers who would like to enable one, set the environment variable ``REACT_APP_ENABLE_SERVICE_WORKER=true`` during installation."
msgstr ""

#: ../../source/developer/metrics.rst:4
#: ../../source/developer/metrics.rst:15
msgid "Metrics"
msgstr ""

#: ../../source/developer/metrics.rst:7
msgid "Event Overview"
msgstr ""

#: ../../source/developer/metrics.rst:9
msgid "The following table illustrates the event and pipeline processing sequence as it relates to some of the metrics described in :ref:`statsd`.  This is intended as general guidance only and is not an exhaustive list."
msgstr ""

#: ../../source/developer/metrics.rst:15
msgid "Event"
msgstr ""

#: ../../source/developer/metrics.rst:15
msgid "Attribute"
msgstr ""

#: ../../source/developer/metrics.rst:17
msgid "Event generated by source"
msgstr ""

#: ../../source/developer/metrics.rst:22
msgid "[8]"
msgstr ""

#: ../../source/developer/metrics.rst:37
msgid "[9]"
msgstr ""

#: ../../source/developer/metrics.rst:17
msgid "event.timestamp"
msgstr ""

#: ../../source/developer/metrics.rst:19
msgid "Enqueued into driver queue"
msgstr ""

#: ../../source/developer/metrics.rst:21
msgid "Enqueued into tenant trigger queue"
msgstr ""

#: ../../source/developer/metrics.rst:23
msgid "[1]"
msgstr ""

#: ../../source/developer/metrics.rst:21
msgid "event.arrived_at_scheduler_timestamp"
msgstr ""

#: ../../source/developer/metrics.rst:23
msgid "Forwarded to matching pipelines"
msgstr ""

#: ../../source/developer/metrics.rst:25
msgid "Changes enqueued ahead"
msgstr ""

#: ../../source/developer/metrics.rst:27
msgid "Change enqueued"
msgstr ""

#: ../../source/developer/metrics.rst:27
msgid "item.enqueue_time"
msgstr ""

#: ../../source/developer/metrics.rst:29
msgid "Changes enqueued behind"
msgstr ""

#: ../../source/developer/metrics.rst:31
msgid "Set item configuration"
msgstr ""

#: ../../source/developer/metrics.rst:31
msgid "build_set.configured_time"
msgstr ""

#: ../../source/developer/metrics.rst:33
msgid "Request files changed (if needed)"
msgstr ""

#: ../../source/developer/metrics.rst:35
msgid "[2]"
msgstr ""

#: ../../source/developer/metrics.rst:35
msgid "Request merge"
msgstr ""

#: ../../source/developer/metrics.rst:37
msgid "Wait for merge (and files if needed)"
msgstr ""

#: ../../source/developer/metrics.rst:39
msgid "Generate dynamic layout (if needed)"
msgstr ""

#: ../../source/developer/metrics.rst:39
msgid "[3]"
msgstr ""

#: ../../source/developer/metrics.rst:41
msgid "Freeze job graph"
msgstr ""

#: ../../source/developer/metrics.rst:41
msgid "[4]"
msgstr ""

#: ../../source/developer/metrics.rst:43
msgid "Request global repo state (if needed)"
msgstr ""

#: ../../source/developer/metrics.rst:44
msgid "[5]"
msgstr ""

#: ../../source/developer/metrics.rst:43
msgid "build_set.repo_state_request_time"
msgstr ""

#: ../../source/developer/metrics.rst:45
msgid "Wait for global repo state (if needed)"
msgstr ""

#: ../../source/developer/metrics.rst:47
msgid "Deduplicate jobs"
msgstr ""

#: ../../source/developer/metrics.rst:49
msgid "Acquire semaphore (non-resources-first)"
msgstr ""

#: ../../source/developer/metrics.rst:51
msgid "Request nodes"
msgstr ""

#: ../../source/developer/metrics.rst:52
msgid "[6]"
msgstr ""

#: ../../source/developer/metrics.rst:51
msgid "request.created_time"
msgstr ""

#: ../../source/developer/metrics.rst:53
msgid "Wait for nodes"
msgstr ""

#: ../../source/developer/metrics.rst:55
msgid "Acquire semaphore (resources-first)"
msgstr ""

#: ../../source/developer/metrics.rst:57
msgid "Enqueue build request"
msgstr ""

#: ../../source/developer/metrics.rst:58
msgid "[7]"
msgstr ""

#: ../../source/developer/metrics.rst:57
msgid "build.execute_time"
msgstr ""

#: ../../source/developer/metrics.rst:59
msgid "Executor starts job"
msgstr ""

#: ../../source/developer/metrics.rst:59
msgid "build.start_time"
msgstr ""

#: ../../source/developer/metrics.rst:63
msgid "Metric"
msgstr ""

#: ../../source/developer/metrics.rst:63
msgid "Name"
msgstr ""

#: ../../source/developer/metrics.rst:65
msgid "1"
msgstr ""

#: ../../source/developer/metrics.rst:65
msgid "event_enqueue_processing_time"
msgstr ""

#: ../../source/developer/metrics.rst:66
msgid "2"
msgstr ""

#: ../../source/developer/metrics.rst:66
msgid "merge_request_time"
msgstr ""

#: ../../source/developer/metrics.rst:67
msgid "3"
msgstr ""

#: ../../source/developer/metrics.rst:67
msgid "layout_generation_time"
msgstr ""

#: ../../source/developer/metrics.rst:68
msgid "4"
msgstr ""

#: ../../source/developer/metrics.rst:68
msgid "job_freeze_time"
msgstr ""

#: ../../source/developer/metrics.rst:69
msgid "5"
msgstr ""

#: ../../source/developer/metrics.rst:69
msgid "repo_state_time"
msgstr ""

#: ../../source/developer/metrics.rst:70
msgid "6"
msgstr ""

#: ../../source/developer/metrics.rst:70
msgid "node_request_time"
msgstr ""

#: ../../source/developer/metrics.rst:71
msgid "7"
msgstr ""

#: ../../source/developer/metrics.rst:71
msgid "job_wait_time"
msgstr ""

#: ../../source/developer/metrics.rst:72
msgid "8"
msgstr ""

#: ../../source/developer/metrics.rst:72
msgid "event_enqueue_time"
msgstr ""

#: ../../source/developer/metrics.rst:73
msgid "9"
msgstr ""

#: ../../source/developer/metrics.rst:73
msgid "event_job_time"
msgstr ""

#: ../../source/developer/model-changelog.rst:2
msgid "Data Model Changelog"
msgstr ""

#: ../../source/developer/model-changelog.rst:4
msgid "Record changes to the ZooKeeper data model which require API version increases here."
msgstr ""

#: ../../source/developer/model-changelog.rst:7
msgid "When making a model change:"
msgstr ""

#: ../../source/developer/model-changelog.rst:9
msgid "Increment the value of ``MODEL_API`` in ``model_api.py``."
msgstr ""

#: ../../source/developer/model-changelog.rst:10
msgid "Update code to use the new API by default and add backwards-compatibility handling for older versions.  This makes it easier to clean up backwards-compatibility handling in the future."
msgstr ""

#: ../../source/developer/model-changelog.rst:13
msgid "Make sure code that special cases model versions either references a ``model_api`` variable or has a comment like `MODEL_API: > {version}` so that we can grep for that and clean up compatibility code that is no longer needed."
msgstr ""

#: ../../source/developer/model-changelog.rst:17
msgid "Add a test to ``test_model_upgrade.py``."
msgstr ""

#: ../../source/developer/model-changelog.rst:18
msgid "Add an entry to this log so we can decide when to remove backwards-compatibility handlers."
msgstr ""

#: ../../source/developer/model-changelog.rst:22
msgid "Version 0"
msgstr ""

#: ../../source/developer/model-changelog.rst:0
msgid "Prior Zuul version"
msgstr ""

#: ../../source/developer/model-changelog.rst:24
#: ../../source/developer/model-changelog.rst:31
msgid "4.11.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:0
msgid "Description"
msgstr ""

#: ../../source/developer/model-changelog.rst:25
msgid "This is an implied version as of Zuul 4.12.0 to initialize the series."
msgstr ""

#: ../../source/developer/model-changelog.rst:29
msgid "Version 1"
msgstr ""

#: ../../source/developer/model-changelog.rst:32
msgid "No change since Version 0.  This explicitly records the component versions in ZooKeeper."
msgstr ""

#: ../../source/developer/model-changelog.rst:36
msgid "Version 2"
msgstr ""

#: ../../source/developer/model-changelog.rst:38
#: ../../source/developer/model-changelog.rst:45
msgid "5.0.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:39
msgid "Changes the semaphore handle format from `<item_uuid>-<job_name>` to a dictionary with buildset path and job name."
msgstr ""

#: ../../source/developer/model-changelog.rst:43
msgid "Version 3"
msgstr ""

#: ../../source/developer/model-changelog.rst:46
msgid "Add a new `SupercedeEvent` and use that for dequeuing of superceded items from other pipelines. This only affects the schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:51
msgid "Version 4"
msgstr ""

#: ../../source/developer/model-changelog.rst:53
#: ../../source/developer/model-changelog.rst:61
msgid "5.1.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:54
msgid "Adds QueueItem.dequeued_missing_requirements and sets it to True if a change no longer meets merge requirements in dependent pipelines.  This only affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:59
msgid "Version 5"
msgstr ""

#: ../../source/developer/model-changelog.rst:62
msgid "Changes the result data attributes on Build from ResultData to JobData instances and uses the inline/offloading paradigm from FrozenJob.  This affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:68
msgid "Version 6"
msgstr ""

#: ../../source/developer/model-changelog.rst:70
msgid "5.2.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:71
msgid "Stores the complete layout min_ltimes in /zuul/layout-data. This only affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:75
msgid "Version 7"
msgstr ""

#: ../../source/developer/model-changelog.rst:77
msgid "5.2.2"
msgstr ""

#: ../../source/developer/model-changelog.rst:78
msgid "Adds the blob store and stores large secrets in it. Playbook secret references are now either an integer index into the job secret list, or a dict with a blob store key.  This affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:84
msgid "Version 8"
msgstr ""

#: ../../source/developer/model-changelog.rst:86
msgid "6.0.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:87
msgid "Deduplicates jobs in dependency cycles.  Affects schedulers only."
msgstr ""

#: ../../source/developer/model-changelog.rst:91
msgid "Version 9"
msgstr ""

#: ../../source/developer/model-changelog.rst:93
msgid "6.3.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:94
msgid "Adds nodeset_alternatives and nodeset_index to frozen job. Removes nodeset from frozen job.  Affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:98
msgid "Version 10"
msgstr ""

#: ../../source/developer/model-changelog.rst:100
msgid "6.4.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:101
msgid "Renames admin_rules to authz_rules in unparsed abide. Affects schedulers and web."
msgstr ""

#: ../../source/developer/model-changelog.rst:105
msgid "Version 11"
msgstr ""

#: ../../source/developer/model-changelog.rst:107
#: ../../source/developer/model-changelog.rst:112
msgid "8.0.1"
msgstr ""

#: ../../source/developer/model-changelog.rst:108
msgid "Adds merge_modes to branch cache.  Affects schedulers and web."
msgstr ""

#: ../../source/developer/model-changelog.rst:111
msgid "Version 12"
msgstr ""

#: ../../source/developer/model-changelog.rst:113
msgid "Adds job_versions and build_versions to BuildSet. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:117
msgid "Version 13"
msgstr ""

#: ../../source/developer/model-changelog.rst:118
#: ../../source/developer/model-changelog.rst:125
msgid "8.2.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:119
msgid "Stores only the necessary event info as part of a queue item instead of the full trigger event. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:124
msgid "Version 14"
msgstr ""

#: ../../source/developer/model-changelog.rst:126
msgid "Adds the pre_fail attribute to builds. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:130
msgid "Version 15"
msgstr ""

#: ../../source/developer/model-changelog.rst:131
#: ../../source/developer/model-changelog.rst:137
msgid "9.0.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:132
msgid "Adds ansible_split_streams to FrozenJob. Affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:136
msgid "Version 16"
msgstr ""

#: ../../source/developer/model-changelog.rst:138
msgid "Adds default_branch to the branch cache. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:142
msgid "Version 17"
msgstr ""

#: ../../source/developer/model-changelog.rst:143
msgid "9.1.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:144
msgid "Adds ZuulRegex and adjusts SourceContext serialization. Affects schedulers and web."
msgstr ""

#: ../../source/developer/model-changelog.rst:148
msgid "Version 18"
msgstr ""

#: ../../source/developer/model-changelog.rst:149
#: ../../source/developer/model-changelog.rst:155
#: ../../source/developer/model-changelog.rst:161
msgid "9.2.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:150
msgid "Adds new merge modes 'recursive' and 'ort' for the Github driver."
msgstr ""

#: ../../source/developer/model-changelog.rst:154
msgid "Version 19"
msgstr ""

#: ../../source/developer/model-changelog.rst:156
msgid "Changes the storage path of a frozen job to use the job's UUID instead of the name as identifier."
msgstr ""

#: ../../source/developer/model-changelog.rst:160
msgid "Version 20"
msgstr ""

#: ../../source/developer/model-changelog.rst:162
msgid "Send (secret) job parent and artifact data via build request parameters instead of updating the job. Affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:167
msgid "Version 21"
msgstr ""

#: ../../source/developer/model-changelog.rst:168
#: ../../source/developer/model-changelog.rst:174
#: ../../source/developer/model-changelog.rst:180
#: ../../source/developer/model-changelog.rst:186
#: ../../source/developer/model-changelog.rst:192
msgid "9.3.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:169
msgid "Add job_dependencies and job_dependents fields to job graphs. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:173
msgid "Version 22"
msgstr ""

#: ../../source/developer/model-changelog.rst:175
msgid "Add model_version field to job graphs and index jobs by uuid. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:179
msgid "Version 23"
msgstr ""

#: ../../source/developer/model-changelog.rst:181
msgid "Add model_version field to build sets. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:185
msgid "Version 24"
msgstr ""

#: ../../source/developer/model-changelog.rst:187
msgid "Add job_uuid to NodeRequests. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:191
msgid "Version 25"
msgstr ""

#: ../../source/developer/model-changelog.rst:193
msgid "Add job_uuid to BuildRequests and BuildResultEvents. Affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:197
msgid "Version 26"
msgstr ""

#: ../../source/developer/model-changelog.rst:198
msgid "9.5.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:199
msgid "Refactor circular dependencies. Affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:203
msgid "Version 27"
msgstr ""

#: ../../source/developer/model-changelog.rst:204
msgid "10.0.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:205
msgid "Refactor branch cache. Affects schedulers and web."
msgstr ""

#: ../../source/developer/model-changelog.rst:209
msgid "Version 28"
msgstr ""

#: ../../source/developer/model-changelog.rst:210
#: ../../source/developer/model-changelog.rst:216
msgid "10.1.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:211
msgid "Store repo state in blobstore. Affects schedulers and executor."
msgstr ""

#: ../../source/developer/model-changelog.rst:215
msgid "Version 29"
msgstr ""

#: ../../source/developer/model-changelog.rst:217
msgid "Store BuildSet.dependent_changes as change refs. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:221
msgid "Version 30"
msgstr ""

#: ../../source/developer/model-changelog.rst:222
msgid "10.2.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:223
msgid "Store playbook nesting_level and cleanup on frozen job. Affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:227
msgid "Version 31"
msgstr ""

#: ../../source/developer/model-changelog.rst:228
msgid "11.0.1"
msgstr ""

#: ../../source/developer/model-changelog.rst:229
msgid "Upgrade sharded zkobject format."
msgstr ""

#: ../../source/developer/model-changelog.rst:232
msgid "Version 32"
msgstr ""

#: ../../source/developer/model-changelog.rst:233
msgid "11.1.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:234
msgid "Add topic query timestamp. Affects schedulers."
msgstr ""

#: ../../source/developer/model-changelog.rst:238
msgid "Version 33"
msgstr ""

#: ../../source/developer/model-changelog.rst:239
msgid "11.2.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:240
msgid "Send SemaphoreReleaseEvents to the tenant management event queue instead of the pipeline trigger event queue. Affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:245
msgid "Version 34"
msgstr ""

#: ../../source/developer/model-changelog.rst:246
#: ../../source/developer/model-changelog.rst:252
msgid "11.3.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:247
msgid "Don't store deprecated web ``status_url`` in system attributes anymore. Affects schedulers and web."
msgstr ""

#: ../../source/developer/model-changelog.rst:251
msgid "Version 35"
msgstr ""

#: ../../source/developer/model-changelog.rst:253
msgid "Updated Secret configuration format to support OIDC token. Affects schedulers and executors."
msgstr ""

#: ../../source/developer/model-changelog.rst:257
msgid "Version 36"
msgstr ""

#: ../../source/developer/model-changelog.rst:258
msgid "13.0.0"
msgstr ""

#: ../../source/developer/model-changelog.rst:259
msgid "Supply tenant_name in ssh_keys to executors. Affects schedulers and executors."
msgstr ""

#: ../../source/developer/releasenotes.rst:2
msgid "Release Notes"
msgstr ""

#: ../../source/developer/releasenotes.rst:4
msgid "Zuul uses `reno`_ for release note management. When adding a noteworthy feature, fixing a noteworthy bug or introducing a behavior change that a user or operator should know about, it is a good idea to add a release note to the same patch."
msgstr ""

#: ../../source/developer/releasenotes.rst:10
msgid "Installing reno"
msgstr ""

#: ../../source/developer/releasenotes.rst:12
msgid "reno has a command, ``reno``, that is expected to be run by developers to create a new release note. The simplest thing to do is to install it locally with pip:"
msgstr ""

#: ../../source/developer/releasenotes.rst:21
msgid "Adding a new release note"
msgstr ""

#: ../../source/developer/releasenotes.rst:23
msgid "Adding a new release note is easy:"
msgstr ""

#: ../../source/developer/releasenotes.rst:29
msgid "Where ``releasenote-slug`` is a short identifier for the release note. reno will then create a file in ``releasenotes/notes`` that contains an initial template with the available sections."
msgstr ""

#: ../../source/developer/releasenotes.rst:33
msgid "The file it creates is a yaml file. All of the sections except for ``prelude`` contain lists, which will be combined with the lists from similar sections in other note files to create a bulleted list that will then be processed by Sphinx."
msgstr ""

#: ../../source/developer/releasenotes.rst:38
msgid "The ``prelude`` section is a single block of text that will also be combined with any other prelude sections into a single chunk."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:2
msgid "Branch-Assigned Queues"
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:4
#: ../../source/developer/specs/init-jobs.rst:4
#: ../../source/developer/specs/nodepool-in-zuul.rst:4
#: ../../source/developer/specs/reporter-jobs.rst:4
#: ../../source/developer/specs/web-rbac.rst:4
msgid "This is not authoritative documentation.  These features are not currently available in Zuul.  They may change significantly before final implementation, or may never be fully completed."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:8
msgid "The following document describes a change to Zuul's shared change queue behavior to support a wider variety of project organizational structures and development methodologies."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:13
#: ../../source/developer/specs/init-jobs.rst:12
#: ../../source/developer/specs/nodepool-in-zuul.rst:14
#: ../../source/developer/specs/reporter-jobs.rst:12
#: ../../source/developer/specs/web-rbac.rst:12
msgid "Introduction"
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:15
msgid "We describe Zuul as a project gating system because the main purpose is to control which changes are merged.  A key to how Zuul performs this activity is controlling the order in which changes are merged. By doing so, Zuul is able to stack multiple changes on top of each other when it builds its proposed future states of multiple repositories."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:22
msgid "In order to ensure the correct co-gating behavior between multiple repositories, all of the repositories which could affect the outcome of integration test jobs must share a single queue so that if changes to project A and project B are to be merged, they are tested together."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:27
msgid "We found early on that it is worthwhile to minimize the number of projects involved in a single queue.  The queue must include all the projects in the integration tests that cover the projects, but ideally no more than that.  If project C is not involved in the testing of projects A and B, then it is counter-productive for a change to C to wait in the queue behind changes to A and B."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:34
msgid "In Zuul, a pipeline defines a workflow action, and it contains one or more queues that it uses when performing that action.  A \"gate\" pipeline in Zuul which is responsible for merging changes may have a single shared queue for all projects, or it may have multiple queues, one for each individual project, or, more typically, a handful of queues each for a collection of projects."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:41
msgid "There are currently two styles of shared change queues.  The traditional behavior is that all changes for all projects that are added to the queue enter that single queue.  That means that changes that involve different branches share a single queue.  This is to support a development process where branches interact with each other. For example, OpenStack ensures that it can upgrade from the most recent stable branch to master.  There is an upgrade job that acts as an integration test between these two branches (just as other jobs act as an integration test between different projects).  In order to ensure changes to either branch don't break the upgrade test job, changes to both branches must be sequenced in the shared change queue."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:53
msgid "The other style is a \"per-branch\" queue.  This facilitates a development process where different branches do not interact with each other.  For example, an embedded system manufacturer may have a branch for one hardware revision, and a different branch for another.  There is no need to coordinate changes between these branches, so the \"per-branch\" setting can be enabled which means that changes to branch X of any involved project go into one queue, and changes to branch Y of any involved project go into another.  This allows developers of different hardware to work independently while still performing integration testing of their whole system."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:64
msgid "A third style of development is currently unsupported: systems where projects have multiple independent branches, but the coordination of those branches across multiple projects is not done by sharing a common branch name.  If we consider the previous \"per-branch\" case, that works under the assumption that all of the branches involved in hardware revision 1 use a name like \"hw1\" and all the branches involved in revision 2 use \"hw2\".  But if a system is composed from arbitrary branches of multiple repositories, there is no way to build corresponding change queues in Zuul.  This document proposes a way to do that."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:76
#: ../../source/developer/specs/init-jobs.rst:30
#: ../../source/developer/specs/reporter-jobs.rst:70
#: ../../source/developer/specs/web-rbac.rst:39
msgid "Proposal"
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:78
msgid "The proposed change is simple: to allow users a third way of composing change queues where individual project-branch combinations can be assigned to specific queues.  In contrast to the traditional and \"per-branch\" queues, we will call this a \"branch-assigned\" queue."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:83
msgid "The default state of any project that is not assigned to a queue is for Zuul to dynamically create a queue that contains only that project.  If a user adds a project to a traditional queue, then all branches of that project are added to that queue.  If the user adds a project to a per-branch queue, then each branch of the project is added to the queue for that branch."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:90
msgid "When a user assigns a project-branch combination to a branch-assigned queue, only that specific project-branch will be added to that queue. Each other project-branch combination may be added to a different queue.  Any project-branch combinations not explicitly specified will be subject to a fallback behavior described below."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:96
msgid "If any branch of the project specifies either a traditional or per-branch queue, then that will be considered the default queue for the project.  If the user does neither, then the default queue for the project will be (as it is now) an automatically created traditional queue that contains only that project.  Any project-branch combination that does not specify a branch-assigned queue will use the default queue for the project."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:104
msgid "The behavior when determining what queue a change for a given project-branch will be assigned to is therefore:"
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:107
msgid "If this project-branch was assigned to a branch-assigned queue, use that"
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:108
msgid "If the project was assigned to a traditional or per-branch queue, use that"
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:109
msgid "Use the automatically created traditional queue"
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:112
#: ../../source/developer/specs/init-jobs.rst:94
#: ../../source/developer/specs/reporter-jobs.rst:130
msgid "User Interface"
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:114
msgid "Currently, a project may only be assigned to a single queue, therefore when we first see a ``queue`` attribute in a ``project`` stanza for a given project, we take that as the project's queue and ignore any subsequent appearances.  That means that if a project has a ``project`` stanza in every branch of its repo, we consider only the one on the master branch and ignore the rest."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:121
msgid "The simplest and most intuitive way to support a branch-assigned queue is to lift this restriction, and therefore, if the ``project`` stanza on the master branch declares ``queue: foo`` and on the stable branch declares ``queue: bar``, then the master branch will be in `foo` and the stable branch in `bar`."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:127
msgid "However, that may be an unexpected behavior change for existing users since they may be relying on the current behavior to ignore obsolete values in older branches.  Or they may remove ``queue`` attributes from ``project`` stanzas in older branches.  Therefore, we should expect users to opt-in to this behavior.  We will add a new attribute to the ``queue`` object itself to indicate what type of queue it is."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:134
msgid "We will add a ``type`` attribute to the queue object which can be one of the following values: ``all-branches``, ``per-branch``, and ``branch-assigned``."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:138
msgid "The ``all-branches`` value will be the default and is the traditional queue behavior.  The ``per-branch`` value will be a synonym for ``per-branch: true``.  The ``per-branch`` attribute will be deprecated."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:143
msgid "We will use the new ``type`` attribute instead of adding a new ``branch-assigned: true`` attribute because ``per-branch`` and ``branch-assigned`` should be mutually exclusive (and neither one is also a traditional ``all-branches`` queue)."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:148
msgid "It will be an error to specify both ``type`` and ``per-branch`` attributes."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:151
msgid "If a ``project`` stanza declares a queue assignment, when considering what project-branch is involved, we will consider the name of the project in the ``project`` stanza.  If the name is a regular expression, then it will apply to all projects that match the regular expression.  If the ``project`` stanza omits the ``branches`` attribute, then we will use the current branch if it appears in an untrusted project.  If it appears in a config project, then it will apply to all branches of the project.  If the ``branches`` attribute is a regular expression, then it will apply to all branches of the project that match the regular expression.  In other words, we will follow the same procedure as outlined in :attr:`project.branches`."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:163
msgid "Only the first queue assignment for a given project-branch combination will be honored; subsequent appearances will be ignored."
msgstr ""

#: ../../source/developer/specs/branch-assigned-queues.rst:166
msgid "The following example would assign `project1@legacy` to the `legacy` queue, while all other branches of the project are assigned to the `general` queue:"
msgstr ""

#: ../../source/developer/specs/index.rst:2
msgid "Specifications"
msgstr ""

#: ../../source/developer/specs/index.rst:4
msgid "This section contains specifications for future Zuul development.  As we work on implementing significant changes, these document our plans for those changes and help us work on them collaboratively. Once a specification is implemented, it should be removed. All relevant details for implemented work must be reflected correctly in Zuul's documentation instead."
msgstr ""

#: ../../source/developer/specs/index.rst:11
msgid "These are not authoritative documentation.  These features are not currently available in Zuul.  They may change significantly before final implementation, or may never be fully completed."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:2
msgid "Initializer Jobs"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:8
msgid "The following specification describes a new type of job in Zuul to make it easier to create the \"dispatch job\" pattern."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:14
msgid "Zuul supports expressing dependencies between jobs and these may be used for a number of purposes, including:"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:17
msgid "Building an artifact once and testing it in multiple jobs"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:18
msgid "Establishing a shared resource for use of other jobs such as an image registry"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:20
msgid "Altering the ``child_jobs`` zuul_return value to skip running certain jobs (the \"dispatch job\" pattern)"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:23
msgid "The last two use cases sometimes involve setting every other job in the project-pipeline config to depend on a certain job.  This can increase maintenance costs as jobs are added or removed from the configuration.  It also makes the configuration difficult to read and understand."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:32
msgid "First, a note on terminology:"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:34
msgid "The correct terminology is `dependencies` and `dependents`, which is confusing, but it's not appropriate to use terms like \"parent\" and \"child\" since we use those for inheritance.  This is another dimension.  To clarify the correct terminology using the wrong terms: the dependency is the parent and the dependent is the child.  So if job A must run to completion before job B, then job A is a dependency of job B, and job B is a dependent of job A."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:42
msgid "To simplify construction of dependencies, we can add a new type of job to Zuul that we will call an `initializer job`.  Modeled after the \"init container\" in Kubernetes, or even the class initializer in object oriented programming, it will run at the start of a buildset before any other jobs."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:49
#: ../../source/developer/specs/reporter-jobs.rst:115
msgid "Implementation"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:51
msgid "When the scheduler constructs the job graph for a buildset, it will automatically make any initializer jobs that it encounters a dependency of every other job listed in the project pipeline config. After that point, behavior will be exactly as if the user had explicitly specified these links.  That means that the initializer job may be used to filter dependents as well using ``zuul_return``."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:58
msgid "If more than one initializer job is specified, this process will be applied to all of them, in order, including the other initializer jobs.  A job graph with 2 init jobs and one normal job would look like this:"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:72
msgid "The result will be that the jobs run to completion individually in the following sequence:"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:75
msgid "init1"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:76
msgid "init2"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:77
msgid "testjob"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:79
msgid "There will be no explicit restriction on the use of dependencies by or against initializer jobs: users will be free to construct explicit dependencies in the usual manner.  This may may result in errors if users construct an unsolvable graph.  For example, an init job may not, in practice, depend on a non-init job since that non-init job would depend on the init job and create a cycle.  The point here is that we aren't creating any new rules, just relying on the existing ones."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:88
msgid "If multiple initializer jobs run and return values using the ``zuul.child_jobs`` variable via zuul_return, we will proceed with the same behavior we have today if mulitple dependencies are run (which is that the intersection of the results is what is run)."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:96
msgid "A new job configuration attribute, ``type`` will be added, and an initializer job will be created by specifying ``initializer`` as its value.  For example:"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:106
msgid "The default type will be ``null``, which represents a normal job (the only type of job today)."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:110
msgid "Other Types of Jobs"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:112
msgid "There are currently no other special job types, but some have been contemplated and may be the subject of future proposals:"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:115
msgid "finalizer jobs"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:116
msgid "reporting jobs"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:118
msgid "The author of this spec is currently working on a spec for \"reporting jobs\".  It is not appropriate to review or discuss the designs of other potential jobs in this spec, however, they should be briefly noted to the degree they may impact decisions we may make here.  We may never choose to implement any other types of jobs, but we should consider that we might, and if so, how we would design initializer jobs to accommodate them."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:126
msgid "A `finalizer` job would simply be the complement of an initializer job.  The very existence of an initializer job that runs at the start of a buildset causes us to imagine a similar job that runs at the end of a buildset.  It could also be called a `cleanup job`."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:131
msgid "A `reporting` job would be a type of job that runs during the reporting phase, after the end of the normal set of jobs."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:134
msgid "With these potential future types of jobs, here are some questions for us to consider:"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:137
msgid "Are we okay with opening the door to special types of jobs like these?  Once we add one, it will be harder to avoid adding more. Of course, each one can be evaluated independently."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:141
msgid "How should we name the different types of jobs in order to make their usage and differences from each other clear.  The proposed names of the jobs envisioned so far attempt to do so by using \"initializer\" and \"finalizer\" to indicate they run at the start and end of the buildset, and \"reporting\" to indicate it runs during the reporting phase."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:148
msgid "Should we call the \"initializer\" job an \"init\" job?  That is shorter, more convenient, and matches Kubernetes terminology (not to mention ``__init__`` in Python).  But we can't call the \"finalizer\" a \"final\" job since we already have a ``final: true`` flag that means something else.  We could call the \"finalizer\" a \"destructor\" but that suggests a purpose that may not match what the job actually does.  Therefore, \"finalizer\" seems the best name for that, and \"initializer\" seems the best complimentary name."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:157
msgid "We don't expect users to have to type it that often anyway."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:159
msgid "How do the different job types relate to each other?  The ones considered here are all mutually exclusive -- they would run at three distinct phases and could not be used in more than one. Therefore, rather than adding three boolean flags to jobs, the proposal here is to add a single `type` attribute so it's clear that a job may be only one type."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:167
#: ../../source/developer/specs/reporter-jobs.rst:193
#: ../../source/developer/specs/web-rbac.rst:166
msgid "Alternatives"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:169
msgid "Considering only the `initializer job`: it is possible to achieve the desired behavior with explicit configuration today, but it is difficult to maintain.  We could keep the status quo with no loss in functionality, at the cost of increased user confusion and maintenance burden."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:175
msgid "Considering the other potential types of jobs: we might name this an `init job` instead, for convenience, but the rational for using `initializer` was described above."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:180
#: ../../source/developer/specs/nodepool-in-zuul.rst:782
msgid "Work Items"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:182
msgid "The work should be straightforward and is likely to be implemented in a single change."
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:185
msgid "Update configloader to support new syntax"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:186
msgid "Update model job graph freeze to add new behavior"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:187
msgid "Document"
msgstr ""

#: ../../source/developer/specs/init-jobs.rst:188
msgid "Add tests and a release note"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:2
msgid "Nodepool in Zuul"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:8
msgid "The following specification describes a plan to move Nodepool's functionality into Zuul and end development of Nodepool as a separate application.  This will allow for more node and image related features as well as simpler maintenance and deployment."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:16
msgid "Nodepool exists as a distinct application from Zuul largely due to historical circumstances: it was originally a process for launching nodes, attaching them to Jenkins, detaching them from Jenkins and deleting them.  Once Zuul grew its own execution engine, Nodepool could have been adopted into Zuul at that point, but the existing loose API meant it was easy to maintain them separately and combining them wasn't particularly advantageous."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:24
msgid "However, now we find ourselves with a very robust framework in Zuul for dealing with ZooKeeper, multiple components, web services and REST APIs.  All of these are lagging behind in Nodepool, and it is time to address that one way or another.  We could of course upgrade Nodepool's infrastructure to match Zuul's, or even separate out these frameworks into third-party libraries.  However, there are other reasons to consider tighter coupling between Zuul and Nodepool, and these tilt the scales in favor of moving Nodepool functionality into Zuul."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:34
msgid "Designing Nodepool as part of Zuul would allow for more features related to Zuul's multi-tenancy.  Zuul is quite good at fault-tolerance as well as scaling, so designing Nodepool around that could allow for better cooperation between node launchers.  Finally, as part of Zuul, Nodepool's image lifecycle can be more easily integrated with Zuul-based workflow."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:41
msgid "There are two Nodepool components: nodepool-builder and nodepool-launcher.  We will address the functionality of each in the following sections on Image Management and Node Management."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:45
msgid "This spec contemplates a new Zuul component to handle image and node management: zuul-launcher.  Much of the Nodepool configuration will become Zuul configuration as well.  That is detailed in its own section, but for now, it's enough to know that the Zuul system as a whole will know what images and node labels are present in the configuration."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:53
msgid "Image Management"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:55
msgid "Part of nodepool-builder's functionality is important to have as a long-running daemon, and part of what it does would make more sense as a Zuul job.  By moving the actual image build into a Zuul job, we can make the activity more visible to users of the system.  It will be easier for users to test changes to image builds (inasmuch as they can propose a change and a check job can run on that change to see if the image builds successfully).  Build history and logs will be visible in the usual way in the Zuul web interface."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:64
msgid "A frequently requested feature is the ability to verify images before putting them into service.  This is not practical with the current implementation of Nodepool because of the loose coupling with Zuul. However, once we are able to include Zuul jobs in the workflow of image builds, it is easier to incorporate Zuul jobs to validate those images as well.  This spec includes a mechanism for that."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:71
msgid "The parts of nodepool-builder that makes sense as a long-running daemon are the parts dealing with image lifecycles.  Uploading builds to cloud providers, keeping track of image builds and uploads, deciding when those images should enter or leave service, and deleting them are all better done with state management and long-running processes (we should know -- early versions of Nodepool attempted to do all of that with Jenkins jobs with limited success)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:79
msgid "The sections below describe how we will implement image management in Zuul."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:82
msgid "First, a reminder that using custom images is optional with Zuul. Many Zuul systems will be able to operate using only stock cloud provider images.  One of the strengths of nodepool-builder is that it can build an image for Zuul without relying on any particular cloud provider images.  A Zuul system whose operator wants to use custom images will need to bootstrap that process, and under the proposed system where images are build in Zuul jobs, that would need to be done using a stock cloud image.  In other words, to bootstrap a system such as OpenDev from scratch, the operators would need to use a stock cloud image to run the job to build the custom image.  Once a custom image is available, further image builds could be run on either the stock cloud image or the custom image.  That decision is left to the operator and involves consideration of fault tolerance and disaster recovery scenarios."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:97
msgid "To build a custom image, an operator will define a fairly typical Zuul job for each image they would like to produce.  For example, a system may have one job to build a debian-stable image, a second job for debian-unstable, a third job for ubuntu-focal, a fourth job for ubuntu-jammy.  Zuul's job inheritance system could be very useful here to deal with many variations of a similar process."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:104
msgid "Currently nodepool-builder will build an image under three circumstances: 1) the image (or the image in a particular format) is missing; 2) a user has directly requested a build; 3) on an automatic interval (typically daily).  To map this into Zuul, we will use Zuul's existing pipeline functionality, but we will add a new trigger for case #1.  Case #2 can be handled by a manual Zuul enqueue command, and case #3 by a periodic pipeline trigger."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:112
msgid "Since Zuul knows what images are configured and what their current states are, it will be able to emit trigger events when it detects that a new image (or image format) has been added to its configuration.  In these cases, the `zuul` driver in Zuul will enqueue an `image-build` trigger event on startup or reconfiguration for every missing image.  The event will include the image name.  Pipelines will be configured to trigger on `image-build` events as well as on a timer trigger."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:121
msgid "Jobs will include an extra attribute to indicate they build a particular image.  This serves two purposes; first, in the case of an `image-build` trigger event, it will act as a matcher so that only jobs matching the image that needs building are run.  Second, it will allow Zuul to determine which formats are needed for that image (based on which providers are configured to use it) and include that information as job data."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:129
msgid "The job will be responsible for building the image and uploading the result to some storage system.  The URLs for each image format built should be returned to Zuul as artifacts."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:133
msgid "Finally, the `zuul` driver reporter will accept parameters which will tell it to search the result data for these artifact URLs and update the internal image state accordingly."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:137
msgid "An example configuration for a simple single-stage image build:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:158
msgid "This job would run whenever Zuul determines it needs a new debian-unstable image or daily at midnight.  Once the job completes, because of the ``image-built: true`` report, it will look for artifact data like this:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:179
msgid "Zuul will update internal records in ZooKeeper for the image to record the storage URLs.  The zuul-launcher process will then start background processes to download the images from the storage system and upload them to the configured providers (much as nodepool-builder does now with files on disk).  As a special case, it may detect that the image files are stored in a location that a provider can access directly for import and may be able to import directly from the storage location rather than downloading locally first."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:188
msgid "To handle image validation, a flag will be stored for each image upload indicating whether it has been validated.  The example above specifies ``image-validated: true`` and therefore Zuul will put the image into service as soon as all image uploads are complete. However, if it were false, then Zuul would emit an `image-validate` event after each upload is complete.  A second pipeline can be configured to perform image validation.  It can run any number of jobs, and since Zuul has complete knowledge of image states, it will supply nodes using the new image upload (which is not yet in service for normal jobs).  An example of this might look like:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:219
msgid "The label should specify the same image that is being validated.  Its node request will be made with extra specifications so that it is fulfilled with a node built from the image under test.  This process may repeat for each of the providers using that image (normal pipeline queue deduplication rules may need a special case to allow this). Once the validation jobs pass, the entry in ZooKeeper will be updated and the image will go into regular service."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:227
msgid "A more specific process definition follows:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:229
msgid "After a buildset reports with ``image-built: true``, Zuul will scan result data and for each artifact it finds, it will create an entry in ZooKeeper at `/zuul/images/<image_name>/<uuid>`.  Zuul will know not to emit any more `image-build` events for that image at this point."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:235
msgid "For every provider using that image, Zuul will create an entry in ZooKeeper at `/zuul/image-uploads/<image_name>/<image_number>/provider/<provider_name>`. It will set the remote image ID to null and the `image-validated` flag to whatever was specified in the reporter."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:241
msgid "Whenever zuul-launcher observes a new `image-upload` record without an ID, it will:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:244
msgid "Lock the whole image"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:245
msgid "Lock each upload it can handle"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:246
msgid "Unlocks the image while retaining the upload locks"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:247
msgid "Downloads artifact (if needed) and uploads images to provider"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:248
msgid "If upload requires validation, it enqueues an `image-validate` zuul driver trigger event"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:249
msgid "Unlocks upload"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:251
msgid "The locking sequence is so that a single launcher can perform multiple uploads from a single artifact download if it has the opportunity."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:254
msgid "Once more than two builds of an image are in service, the oldest is deleted.  The image ZooKeeper record set to the `deleting` state. Zuul-launcher will delete the uploads from the providers.  The `zuul` driver emits an `image-delete` event with item data for the image artifact.  This will trigger an image-delete job that can delete the artifact from the cloud storage."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:261
msgid "All of these pipeline definitions should typically be in a single tenant (but need not be), but the images they build are potentially available to each tenant that includes the image definition configuration object (see the Configuration section below).  Any repo in a tenant with an image build pipeline will be able to cause images to be built and uploaded to providers."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:269
msgid "Snapshot Images"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:271
msgid "Nodepool does not currently support snapshot images, but the spec for the current version of Nodepool does contemplate the possibility of a snapshot based nodepool-builder process.  Likewise, this spec does not require us to support snapshot image builds, but in case we want to add support in the future, we should have a plan for it."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:277
msgid "The image build job in Zuul could, instead of running diskimage-builder, act on the remote node to prepare it for a snapshot.  A special job attribute could indicate that it is a snapshot image job, and instead of having the zuul-launcher component delete the node at the end of the job, it could snapshot the node and record that information in ZooKeeper.  Unlike an image-build job, an image-snapshot job would need to run in each provider (similar to how it is proposed that an image-validate job will run in each provider). An image-delete job would not be required."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:289
msgid "Node Management"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:291
msgid "The techniques we have developed for cooperative processing in Zuul can be applied to the node lifecycle.  This is a good time to make a significant change to the nodepool protocol.  We can achieve several long-standing goals:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:296
msgid "Scaling and fault-tolerance: rather than having a 1:N relationship of provider:nodepool-launcher, we can have multiple zuul-launcher processes, each of which is capable of handling any number of providers."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:301
msgid "Parallel processing without explicit coordination: a single launcher might not be able to fully utilize a provider due to e.g. CPU or I/O constraints; by having multiple launchers processing requests for a provider, we can better use the available cloud resources."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:306
msgid "More intentional request fulfillment: almost no intelligence goes into selecting which provider will fulfill a given node request; by assigning providers intentionally, we can more efficiently utilize providers."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:311
msgid "Fulfilling node requests from multiple providers: by designing zuul-launcher for cooperative work, we can have nodesets that request nodes which are fulfilled by different providers.  Generally we should favor the same provider for a set of nodes (since they may need to communicate over a LAN), but if that is not feasible, allowing multiple providers to fulfill a request will permit nodesets with diverse node types (e.g., VM + static, or VM + container)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:320
msgid "Zuul-launcher will need to know about every connection in the system so that it may have a full copy of the configuration, but operators may wish to localize launchers to specific clouds.  To support this, zuul-launcher will take an optional command-line argument to indicate on which connections it should operate."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:326
msgid "Each zuul-launcher process will execute a number of processing loops in series; first a global request processing loop, and then a processing loop for each configured provider."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:330
msgid "Requests and nodes will be considered by a launcher based on a calculated score. For that we will use `Rendezvous/HRW (highest random weight) hashing <https://en.wikipedia.org/wiki/Rendezvous_hashing>`_ to build a priority list of candidate launchers. The launcher with the highest score will lock and process a request or node."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:336
msgid "The hash will consist of the unique launcher identifiers (e.g. the hostnames from the component registry) and the UUID of the request or node. The chosen hash function here needs to  be fast and doesn't have to be a cryptographic hash function (e.g MurmurHash)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:341
msgid "With this approach nodes/requests are essentially sharded between the available launchers, making explicit coordination mostly unnecessary. By that we can also avoid thundering herd effects and lock races that are observed in Nodepool today."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:346
msgid "The following edge cases need to be considered with this approach:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:348
msgid "When a new launcher starts up it won't process any locked nodes/requests, even though it might have a higher score than existing launchers."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:351
msgid "When a launcher is shut down the node/request is unlocked and the remaining launchers must decide based on the score who should continue with the node/request."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:355
msgid "Currently a node request as a whole may be declined by providers.  We will make that more granular and store information about each node in the request (in other words, individual nodes may be declined by providers)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:360
msgid "All drivers for providers should implement the state machine interface.  Any state machine information currently stored in memory in nodepool-launcher will need to move to ZooKeeper so that other launchers can resume state machine processing."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:365
msgid "The individual provider loop will:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:367
msgid "Iterate over every matching node (highest score) assigned to that provider in `requested` state"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:370
msgid "If the node is locked by another launcher, continue with the next one"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:371
msgid "Lock the node (if not already locked) and set state to `building`"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:372
msgid "Drive the state machine"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:373
msgid "If success, update request"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:374
msgid "If failure, determine if it's a temporary or permanent failure and update the request accordingly"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:376
msgid "If quota available, unpause provider (if paused)"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:378
msgid "The global queue process will:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:380
msgid "Iterate over every matching node request (highest score), and every node within that request"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:383
msgid "If the request is locked by another launcher, continue with the next one"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:384
msgid "Lock the request (if not already locked)"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:385
msgid "If all providers have failed the request, clear all temp failures"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:386
msgid "If all providers have permanently failed the request, return error"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:387
msgid "Identify providers capable of fulfilling the request"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:388
msgid "Assign nodes to any provider with sufficient quota"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:389
msgid "If no providers with sufficient quota, assign it to first (highest priority) provider that can fulfill it later and pause that provider"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:395
msgid "Quota Handling & Rate Limiting"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:397
msgid "Due to additional the level of parallelization we need to consider quota handling (provider and tenant) as well as provider rate limits."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:400
msgid "The Nodepool launcher implementation as it is today will check whether there is any remaining quota independently for each node request. Quota calculations are based on cached information about existing nodes. This means that concurrently processed requests in different provider pools (Nodepool only supports one launcher per provider) will not consider each other's resource usage and there might also be a small delay until new nodes show up in the cache."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:407
msgid "The same is true for the tenant quota that considers resources used by all providers."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:410
msgid "With the new launcher architecture, the main difference will be that the possibility for quota races increases when scaling up the number launcher instances (more requests are processed in parallel)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:414
msgid "This means that we have to relax the provider quota guarantees that we have in Nodepool today. As a counter-measure we can calculate needed quota when assigning a request to a provider as well as on the provider level before actually acquiring resources. Additionally we can handled quota errors gracefully by re-assigning the node to a different provider."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:420
msgid "Rate limiting in Nodepool today works based on a rate-limiter with the rate configured at the provider level. Multiple provider pools will all respect the global provider rate limit. With multiple launchers for a single provider we can no longer rely on a fixed provider rate limit."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:425
msgid "Instead we need to handle rate-limits and API throttling in the respective drivers and adjust the request rate dynamically based on e.g. API response headers or errors."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:431
msgid "Configuration"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:433
msgid "The configuration currently handled by Nodepool will be refactored and added to Zuul's configuration syntax.  It will be loaded directly from git repos like most Zuul configuration, however it will be non-speculative (like pipelines and semaphores -- changes must merge before they take effect)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:439
msgid "Information about connecting to a cloud will be added to ``zuul.conf`` as a ``connection`` entry.  The rate limit setting will be moved to the connection configuration.  Providers will then reference these connections by name."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:444
msgid "Because providers and images reference global (i.e., outside tenant scope) concepts, ZooKeeper paths for data related to those should include the canonical name of the repo where these objects are defined.  For example, a `debian-unstable` image in the `opendev/images` repo should be stored at ``/zuul/zuul-images/opendev.org%2fopendev%2fimages/``.  This avoids collisions if different tenants contain different image objects with the same name."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:453
msgid "The actual Zuul config objects will be tenant scoped.  Image definitions which should be available to a tenant should be included in that tenant's config.  Again using the OpenDev example, the hypothetical `opendev/images` repository should be included in every OpenDev tenant so all of those images are available."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:459
msgid "Within a tenant, image names must be unique (otherwise it is a tenant configuration error, similar to a job name collision)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:462
msgid "The diskimage-builder related configuration items will no longer be necessary since they will be encoded in Zuul jobs.  This will reduce the complexity of the configuration significantly."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:466
msgid "The provider configuration will change as we take the opportunity to make it more \"Zuul-like\".  Instead of a top-level dictionary, we will use lists.  We will standardize on attributes used across drivers where possible, as well as attributes which may be located at different levels of the configuration."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:472
msgid "The goals of this reorganization are:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:474
msgid "Allow projects to manage their own image lifecycle (if permitted by site administrators)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:476
msgid "Manage access control to labels, images and flavors via standard Zuul mechanisms (whether an item appears within a tenant)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:478
msgid "Reduce repetition and boilerplate for systems with many clouds, labels, or images."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:481
msgid "The new configuration objects are:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:483
msgid "Image"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:484
msgid "This represents any kind of image (A Zuul image built by a job described above, or a cloud image).  By using one object to represent both, we open the possibility of having a label in one provider use a cloud image and in another provider use a Zuul image (because the label will reference the image by short-name which may resolve to a different image object in different tenants).  A given image object will specify what type it is, and any relevant information about it (such as the username to use, etc)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:493
msgid "Flavor"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:494
msgid "This is a new abstraction layer to reference instance types across different cloud providers.  Much like labels today, these probably won't have much information associated with them other than to reserve a name for other objects to reference.  For example, a site could define a `small` and a `large` flavor.  These would later be mapped to specific instance types on clouds."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:501
msgid "Label"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:502
msgid "Unlike the current Nodepool ``label`` definitions, these labels will also specify the image and flavor to use.  These reference the two objects above, which means that labels themselves contain the high-level definition of what will be provided (e.g., a `large ubuntu` node) while the specific mapping of what `large` and `ubuntu` mean are left to the more specific configuration levels."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:509
msgid "Section"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:510
msgid "This looks a lot like the current ``provider`` configuration in Nodepool (but also a little bit like a ``pool``).  Several parts of the Nodepool configuration (such as separating out availability zones from providers into pools) were added as an afterthought, and we can take the opportunity to address that here."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:516
msgid "A ``section`` is part of a cloud.  It might be a region (if a cloud has regions).  It might be one or more availability zones within a region.  A lot of the specifics about images, flavors, subnets, etc., will be specified here.  Because a cloud may have many sections, we will implement inheritance among sections."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:522
msgid "Provider"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:523
msgid "This is mostly a mapping of labels to sections and is similar to a provider pool in the current Nodepool configuration.  It exists as a separate object so that site administrators can restrict ``section`` definitions to central repos and allow tenant administrators to control their own image and labels by allowing certain projects to define providers."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:530
msgid "It mostly consists of a list of labels, but may also include images."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:532
msgid "When launching a node, relevant attributes may come from several sources (the pool, image, flavor, or provider).  Not all attributes make sense in all locations, but where we can support them in multiple locations, the order of application (later items override earlier ones) will be:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:538
msgid "``image`` stanza"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:539
msgid "``flavor`` stanza"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:540
msgid "``label`` stanza"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:541
msgid "``section`` stanza (top level)"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:542
msgid "``image`` within ``section``"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:543
msgid "``flavor`` within ``section``"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:544
msgid "``provider`` stanza (top level)"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:545
msgid "``label`` within ``provider``"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:547
msgid "This reflects that the configuration is built upwards from general and simple objects toward more specific objects image, flavor, label, section, provider.  Generally speaking, inherited scalar values will override, dicts will merge, lists will concatenate."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:552
msgid "An example configuration follows.  First, some configuration which may appear in a central project and shared among multiple tenants:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:642
msgid "The following configuration might appear in a repo that is only used in a single tenant:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:664
msgid "Here is a potential static node configuration:"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:687
msgid "Each of the above stanzas may only appear once in a tenant for a given name (like pipelines or semaphores, they are singleton objects). If they appear in more than one branch of a project, the definitions must be identical; otherwise, or if they appear in more than one repo, the second definition is an error.  These are meant to be used in unbranched repos.  Whatever tenants they appear in will be permitted to access those respective resources."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:695
msgid "The purpose of the ``provider`` stanza is to associate labels, images, and sections.  Much of the configuration related to launching an instance (including the availability of zuul or cloud images) may be supplied in the ``provider`` stanza and will apply to any labels within.  The ``section`` stanza also allows configuration of the same information except for the labels themselves.  The ``section`` supplies default values and the ``provider`` can override them or add any missing values.  Images are additive -- any images that appear in a ``provider`` will augment those that appear in a ``section``."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:705
msgid "The result is a modular scheme for configuration, where a single ``section`` instance can be used to set as much information as possible that applies globally to a provider.  A simple configuration may then have a single ``provider`` instance to attach labels to that section.  A more complex installation may define a \"standard\" pool that is present in every tenant, and then tenant-specific pools as well.  These pools will all attach to the same section."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:713
msgid "References to sections, images and labels will be internally converted to canonical repo names to avoid ambiguity.  Under the current Nodepool system, labels are truly a global object, but under this proposal, a label short name in one tenant may be different than one in another.  Therefore the node request will internally specify the canonical label name instead of the short name.  Users will never use canonical names, only short names."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:721
msgid "For static nodes, there is some repetition to labels: first labels must be associated with the individual nodes defined on the section, then the labels must appear again on a provider.  This allows an operator to define a collection of static nodes centrally on a section, then include tenant-specific sets of labels in a provider. For the simple case where all static node labels in a section should be available in a provider, we could consider adding a flag to the provider to allow that (e.g., ``include-all-node-labels: true``). Static nodes themselves are configured on a section with a ``null`` connection (since there is no cloud provider associated with static nodes).  In this case, the additional ``nodes`` section attribute becomes available."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:735
msgid "Upgrade Process"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:737
msgid "Most users of diskimages will need to create new jobs to build these images.  This proposal also includes significant changes to the node allocation system which come with operational risks."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:741
msgid "To make the transition as minimally disruptive as possible, we will support both systems in Zuul, and allow for selection of one system or the other on a per-label and per-tenant basis."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:745
msgid "By default, if a nodeset specifies a label that is not defined by a ``label`` object in the tenant, Zuul will use the old system and place a ZooKeeper request in ``/nodepool``.  If a matching ``label`` is available in the tenant, The request will use the new system and be sent to ``/zuul/node-requests``.  Once a tenant has completely converted, a configuration flag may be set in the tenant configuration and that will allow Zuul to treat nodesets that reference unknown labels as configuration errors.  A later version of Zuul will remove the backwards compatibility and make this the standard behavior."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:755
msgid "Because each of the systems will have unique metadata, they will not recognize each others nodes, and it will appear to each that another system is using part of their quota.  Nodepool is already designed to handle this case (at least, handle it as well as possible)."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:761
msgid "Library Requirements"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:763
msgid "The new zuul-launcher component will need most of Nodepool's current dependencies, which will entail adding many third-party cloud provider interfaces.  As of writing, this uses another 420M of disk space. Since our primary method of distribution at this point is container images, if the additional space is a concern, we could restrict the installation of these dependencies to only the zuul-launcher image."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:771
msgid "Diskimage-Builder Testing"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:773
msgid "The diskimage-builder project team has come to rely on Nodepool in its testing process.  It uses Nodepool to upload images to a devstack cloud, launch nodes from those instances, and verify that they function.  To aid in continuity of testing in the diskimage-builder project, we will extract the OpenStack image upload and node launching code into a simple Python script that can be used in diskimage-builder test jobs in place of Nodepool."
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:784
msgid "In existing Nodepool convert the following drivers to statemachine: gce, kubernetes, openshift, openshift, openstack (openstack is the only one likely to require substantial effort, the others should be trivial)"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:788
msgid "Replace Nodepool with an image upload script in diskimage-builder test jobs"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:790
msgid "Add roles to zuul-jobs to build images using diskimage-builder"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:791
msgid "Implement node-related config items in Zuul config and Layout"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:792
msgid "Create zuul-launcher executable/component"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:793
msgid "Add image-name item data"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:794
msgid "Add image-build-name attribute to jobs * Including job matcher based on item image-name * Include image format information based on global config"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:797
msgid "Add zuul driver pipeline trigger/reporter"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:798
msgid "Add image lifecycle manager to zuul-launcher * Emit image-build events * Emit image-validate events * Emit image-delete events"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:802
msgid "Add Nodepool driver code to Zuul"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:803
msgid "Update zuul-launcher to perform image uploads and deletion"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:804
msgid "Implement node launch global request handler"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:805
msgid "Implement node launch provider handlers"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:806
msgid "Update Zuul nodepool interface to handle both Nodepool and zuul-launcher node request queues"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:808
msgid "Add tenant feature flag to switch between them"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:809
msgid "Release a minor version of Zuul with support for both"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:810
msgid "Remove Nodepool support from Zuul"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:811
msgid "Release a major version of Zuul with only zuul-launcher support"
msgstr ""

#: ../../source/developer/specs/nodepool-in-zuul.rst:812
msgid "Retire Nodepool"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:2
msgid "Reporter Jobs"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:8
msgid "The following document describes a new type of job designed to be run during the reporting phase in Zuul."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:14
msgid "Zuul uses pipelines to describe workflow operations.  Pipelines utilize a number of concepts: triggers determine what items are enqueued into a pipeline, jobs are run for the items in the pipeline, and reporters send results based on the outcome of jobs."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:19
msgid "The reporting phase is critical because in a \"gate\" pipeline (which is Zuul's main purpose) one of the reporters is responsible for actually causing the change being tested to merge.  It executes the atomic state transition which changes Zuul's speculative future state into the actual present state.  Originally, and still typically, the only thing that changes in that instant is the merging of a single commit into a single repository.  But there are some exceptions."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:27
msgid "With circular dependencies, multiple commits may be merged during the reporting phase of a single item.  To accomplish this, Zuul attempts to leave feedback on all the changes in the cycle first, and after completing that it then instructs the code review system(s) to merge the changes.  It's as close to a two-phase commit as we can get without being able to roll back."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:34
msgid "One code review system in particular, Gerrit, can do even more during that instant where Zuul is merging the change(s) for a queue item. Due to Gerrit's superproject subscription feature, at the moment a change is merged to a project, any superprojects in Gerrit (that is, projects with .gitmodules files that reference the target project as a submodule) may have their .gitmodules files updated to point at the commit sha of the newly merged change.  This allows for a near atomic update of not only the project whose change is being merged, but the superproject that consumes it."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:44
msgid "Users of other systems have expressed a desire for a similar behavior, but lacking support for that behavior in the code review systems themselves, they naturally look to Zuul as an option.  The same is true for users of project composition systems other than git submodules, such as the \"repo\" tool from Android.  The only current option is to have an external system monitor Zuul and then perform the update as quickly as possible."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:52
msgid "However, this introduces a race condition that can affect Zuul itself. Consider the following sequence:"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:55
msgid "Change A completes testing in the gate pipeline and is merged"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:56
msgid "External system observes the merging of change A and starts updating the superproject"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:57
msgid "User approves change B and it is enqueued into Zuul"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:58
msgid "Zuul performs a repo state job to fix the state of all repos for change B"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:59
msgid "External system completes the update of the superproject"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:61
msgid "At the end of this process, Zuul may run jobs for change B with repo states that include change A as merged into the subproject but without the superproject being updated to account for that."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:65
msgid "Since performing this update is a workload involving git repos, and Zuul is quite good at running arbitrary workloads involving git repos, this is a proposal for a new kind of Zuul job to accommodate this need."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:72
msgid "The key to running this kind of workload is that it must happen after the completion of the report to the code review system where the change is merged, but before Zuul resumes processing of that pipeline. It must be fast, because Zuul will not be able to make any changes to the pipeline until the job is complete."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:78
msgid "One of the main benefits of running this kind of workflow in Zuul is that users will benefit from the logging and accessibility that Zuul provides for all jobs.  Rather than having a critical part of the development process happen in an external tool which may not be visible to developers, by running it in a Zuul job, we should be able to see the whole process as easily as we see the rest of the software development."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:86
msgid "To that end, the job should be included in the buildset that is reported to the SQL database, though it will have run too late to be included in the reports to the code review systems.  The result of the job may still affect the result of the buildset.  If the job fails, the buildset would switch from SUCCESS to FAILURE and the changes behind it will reconfigure themselves just as if the merge operation itself failed.  That will allow them to run with the most accurate information possible, and prevent the propagation of errors to changes further back in the queue."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:96
msgid "Since a reporter job runs after all jobs in the normal buildset, we will treat all of the jobs in the normal buildset as parent jobs for the purposes of supplying parent job result data to the reporter jobs as variables.  In other words, all of the normal buildset jobs will automatically pass their result data and artifacts to the reporter job.  This will make it easy to use reporter jobs to act on artifacts.  Further, if a user configures multiple reporter jobs with dependencies, those will still work as normal -- child jobs will wait on their parents and additionally get the result data from those jobs. This is probably not advisable, since it will further slow the gating process, but there doesn't seem to be any reason to restrict it."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:108
msgid "We will add new zuul variables that will include information about any merges performed by the pipeline reporters (including the merged commit SHA).  This will facilitate creating jobs that update superprojects."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:117
msgid "The Zuul pipeline manager will be adjusted to do the following:"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:119
msgid "Report the change to all configured pipeline reporters"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:120
msgid "If the buildset was successful, start any reporter jobs configured for the buildset"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:121
msgid "Wait for those jobs to complete: this means that no processing of any items behind the head will happen until the jobs are complete"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:122
msgid "If the buildset failed after running the reporter jobs, cancel jobs behind the head"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:123
msgid "Record the buildset result in the SQL database"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:124
msgid "Continue processing the pipeline"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:126
msgid "It will be recommended that users only configure reporter jobs with empty nodesets, for speed, but it will not be a requirement."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:132
msgid "We will introduce a new job attribute to configure reporter jobs:"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:140
msgid "When such a job is added to a project-pipeline config, the new behavior will be enabled."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:143
msgid "Because this pauses Zuul's operation, we should not, by default, allow untrusted projects to configure reporter jobs themselves (but they can be have reporter jobs configured on them from a trusted project). A reporter job may be added to a project-pipeline config in a project stanza that appears in a trusted project.  Because we also allow some untrusted projects to configure other unstrusted projects, we should allow those to configure this behavior as well.  We will add a tenant configuration option to allow an untrusted project to configure reporter jobs on itself, and if it is also allowed to configure other projects, on them as well.  For example:"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:171
msgid "This would allow the \"superproject\" project to configure reporter jobs on itself or the \"submodule1\" or \"submodule2\" projects.  The \"common-config\" project can configure reporter jobs on any project. The \"submodule1\" and \"submodule2\" projects would not be able to configure their own reporter jobs."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:177
msgid "As an exception to this rule, if a reporter job is declared in a config-project, and also has the `final` flag set to true, any project will be permitted to run that reporter job.  This may be used to allow administrators to configure reporter jobs for general use, such as container promotion jobs."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:184
msgid "Limitations"
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:186
msgid "This approach addresses a race in a \"gate\" pipeline, but if Zuul has other pipelines that trigger when a change is merged, there will be no way to tell them to wait until the superproject is updated.  Users will need to understand this limitation, or, configure such pipelines to act on updates to the superproject only."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:195
msgid "The desired behavior has been prototyped using the MQTT reporter.  The change at https://review.opendev.org/957608 updates the MQTT reporter to optionally wait for a response.  This has enabled the evaluation of the general principle described here.  The MQTT reporter was chosen for this experiment because today it is the reporter of choice for systems that react to Zuul.  However, using the MQTT reporter for this is not ideal because it requires users to write, run, and maintain an external service.  The results of that service are not as visible to users as Zuul jobs are.  It also requires some difficult decisions about timeouts since there is only a loose coupling between Zuul and the external service over MQTT."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:207
msgid "Another alternative would be an HTTP-based reporter.  In this case, we could have Zuul perform an HTTP POST operation and wait for the results.  This is a tighter coupling between Zuul and the external service which addresses one of the shortcomings of the MQTT method. The other shortcomings remain."
msgstr ""

#: ../../source/developer/specs/reporter-jobs.rst:213
msgid "Due to the desirability of tighter integration with the buildset, discoverability of result logs, and obviating the need to create a new service, we elect not to pursue these alternatives."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:2
msgid "Fine-Grained API/Web Access Control"
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:8
msgid "The following document describes a proposed change to the access control system of Zuul's REST API and web user interface."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:14
msgid "Zuul was originally intended to have no user interface, instead only interacting with users through the code-review system.  As the actions that Zuul was able to perform increased in complexity, we developed a read-only web interface in order to visualize what could not be expressed through code-review reporting.  As it continued to increase in complexity, we eventually created read-write endpoints in the API in order to trigger certain administrative actions."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:22
msgid "Today we find Zuul in a position where some of these actions have a wide impact (such as pausing event processing for a tenant) while others have a narrow impact (such as re-enqueing a buildset)."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:26
msgid "Zuul only has two scopes available for authorizing API or web access: per-tenant read access, and per-tenant administrative access.  The only scope available for write access is the administrative scope, so all API actions are either allowed or disallowed for any particular user or group.  For deployments where administrators would like to delegate the ability to autohold nodes, or enqueue/dequeue items, this is proving to be undesirable."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:34
msgid "In order to allow admins to be able to dole out the minimal access required for certain actions, let's add a role-based access control system to the Zuul tenant configuration."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:41
msgid "The existing tenant config file already has some modular components for access control.  We create ``authorization-rule`` objects to encapsulate a description attributes from an identity provider.  These rules may then be attached to a tenant as either an ``admin-rule`` or an ``access-rule`` in order to determine the access level for users who match those rules."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:48
msgid "We can introduce a new object, a ``role``, which specifies fine-grained permissions (such as `autohold`, `enqueue`, and `tenant-state`).  Roles may then be associated with tenants and authorization-rules in order to specify the exact permissions available to users who match a given authorization-rule in a given tenant."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:55
msgid "For convenience, we will define two built-in roles: ``admin`` which will always have all permissions (even if more are added to Zuul in the future), and ``read`` which will have only the permission necessary for read-only access to the tenant."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:60
msgid "Here is an example configuration:"
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:100
msgid "This configuration describes the following:"
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:102
msgid "No anonymous access is allowed."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:103
msgid "Anyone who can authenticate is allowed read-access to the tenant, and the ability to place any autohold in the tenant."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:105
msgid "The \"admin\" user has full access."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:106
msgid "The user named \"alice\" may enqueue items for project \"foo\" into the \"post\" pipeline in that tenant."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:109
msgid "The role mappings are a one-to-many mapping of ``authorization-rule`` to ``role``."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:112
msgid "The roles themselves are generally a collection of permissions.  Some permissions will be boolean (for example, setting the tenant-state to pause event handling).  Others may have conditions added to them, so that they only apply to certain pipelines, projects, etc.  These conditions will vary based on the endpoint being protected.  Because these objects are defined in the tenant config file, which is parsed before the tenant layout is constructed, there will not be any validation of these conditions at configuration time.  Only at run-time will we perform string comparisons of project names or pipeline names, etc."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:123
msgid "To clarify: if there is an error in the tenant configuration at the time the tenant configuration file is parsed, the tenant will not be loaded (if it is a new tenant), or will not be updated and will run with the previous configuration (if it is changed).  This is the current behavior for any tenant configuration file syntax error.  If there is an authorization rule that refers to a project or pipeline that does not exist in the tenant, then that rule will simply not match when it is applied at runtime, and access to the resulting resource will fail with an authorization denied error."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:133
msgid "Because the new role system covers all of the cases currently supported by ``access-rule`` and ``admin-rule`` settings, we will deprecate those settings and ask users to transition to using roles. The built-in ``admin`` and ``read`` roles will make that easy for users who want to make no other changes.  It will be an error to specify ``role-mappings`` and either of the ``-rule`` settings on the same tenant."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:141
msgid "We currently automatically disable anonymous read access for a tenant if any ``access-rule`` is listed on the tenant.  Due to the extra layer of indirection, it would be dangerous to do the same with roles; it would be difficult to audit whether anonymous read access is truly disabled.  Therefore, we will introduce a new boolean flag, ``anonymous-read-access`` which defaults to ``true`` but can be set to ``false``.  This way, users may easily set the baseline behavior for anonymous access, and then, if (and only if) ``anonymous-read-access`` is ``false``, then the ``read`` role permission will be used to determine access."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:152
msgid "The ``api-root`` object currently behaves similarly to tenants, except that it has no ``admin-rule`` attribute, only ``access-rule``. Everything in the preceding paragraph will apply to the ``api-root`` object as well -- it will simply not consult any permissions other than ``read``."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:158
msgid "This spec does not enumerate the permissions and conditions, but it is expected that every zuul-web API endpoint that is currently protected by `admin` access will have a unique permission, and that generally, if those endpoints accept user input (such as project names), we will try to make conditions available for them as well.  Any variances from this can be discussed in the implementing changes."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:168
msgid "Because we are proposing the ability to add conditions to roles that refer to the contents of the tenant layout (such as pipeline or project names), it would make sense to define these role objects within the tenants themselves.  However, that may produce both technical and organizational problems."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:174
msgid "From a technical standpoint, there is no object with which to associate the roles.  Some of them could be attached to a pipeline (for enqueue/dequeue).  Others, such as autohold, might simply be global within the tenant.  That suggests that simply defining a role would make it take effect in the tenant.  That could make it awkward for sites to have a centralized repository with authorization configuration.  Additionally, the existing ``authorization-rule`` objects are defined in the tenant config file, so we would need to consider whether to move them into the layout."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:184
msgid "From an organizational standpoint, much of this authorization configuration deals with permissions that we may not want to grant to users who manage tenant pipeline configurations.  Therefore, the idea of moving this configuration into the layout so that it can be a part of the layout configuration (especially pipelines) is contradicted by the idea that we may not want to give authorization configuration access to the people who manage pipelines."
msgstr ""

#: ../../source/developer/specs/web-rbac.rst:192
msgid "Therefore, the proposal is to keep authorization managed centrally by the Zuul administrators and have only a loose coupling with the contents of the layouts via optional conditions for the permissions."
msgstr ""

#: ../../source/developer/testing.rst:2
msgid "Testing"
msgstr ""

#: ../../source/developer/testing.rst:4
msgid "Zuul provides an extensive framework for performing functional testing on the system from end-to-end with major external components replaced by fakes for ease of use and speed."
msgstr ""

#: ../../source/developer/testing.rst:8
msgid "Test classes that subclass :py:class:`~tests.base.ZuulTestCase` have access to a number of attributes useful for manipulating or inspecting the environment being simulated in the test:"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.simple_layout:1
msgid "Specify a layout file for use by a test method."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.simple_layout:3
msgid "The path to the layout file."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.simple_layout:4
msgid "The source driver to use, defaults to gerrit."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.simple_layout:5
msgid "Enable additional nodepool objects."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.simple_layout:7
msgid "Some tests require only a very simple configuration.  For those, establishing a complete config directory hierachy is too much work.  In those cases, you can add a simple zuul.yaml file to the test fixtures directory (in fixtures/layouts/foo.yaml) and use this decorator to indicate the test method should use that rather than the tenant config file specified by the test class."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.simple_layout:14
msgid "The decorator will cause that layout file to be added to a config-project called \"common-config\" and each \"project\" instance referenced in the layout file will have a git repo automatically initialized."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.simple_layout:19
msgid "The enable_nodepool argument is a temporary facility for convenience during the initial stages of the nodepool-in-zuul work.  It enables the additional nodepool config objects (which are not otherwise enabled by default, but will be later)."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.simple_layout:24
msgid "The replace argument, if provided, is expected to be a callable which returns a dict to use with python template replacement.  It is called with the test as an argument."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:1
msgid "A test case with a functioning Zuul."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:3
msgid "The following class variables are used during test setup and can be overidden by subclasses but are effectively read-only once a test method starts running:"
msgstr ""

#: ../../source/developer/testing.rst:0
msgid "Variables"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:7
msgid "This points to the main zuul config file within the fixtures directory.  Subclasses may override this to obtain a different behavior."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:11
msgid "This is the tenant config file (which specifies from what git repos the configuration should be loaded).  It defaults to the value specified in `config_file` but can be overidden by subclasses to obtain a different tenant/project layout while using the standard main configuration.  See also the :py:func:`simple_layout` decorator."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:19
msgid "This is the tenant config script file. This attribute has the same meaning than tenant_config_file except that the tenant configuration is loaded from a script. When this attribute is set then tenant_config_file is ignored by the scheduler."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:25
msgid "Indicates whether Zuul should auto-generate keys for each project, or whether the test infrastructure should insert dummy keys to save time during startup.  Defaults to False."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:30
msgid "The zuul_stream/zuul_console port."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:32
msgid "The following are instance variables that are useful within test methods:"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:35
msgid "A :py:class:`~tests.base.FakeGerritConnection` will be instantiated for each connection present in the config file and stored here.  For instance, `fake_gerrit` will hold the FakeGerritConnection object for a connection named `gerrit`."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:41
msgid "An instance of :py:class:`~tests.base.RecordingExecutorServer` which is the Ansible execute server used to run jobs for this test."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:45
msgid "A list of :py:class:`~tests.base.FakeBuild` objects representing currently running builds.  They are appended to the list in the order they are executed, and removed from this list upon completion."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase:50
msgid "A list of :py:class:`~tests.base.BuildHistory` objects representing completed builds.  They are appended to the list in the order they complete."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.addEvent:1
msgid "Inject a Fake (Gerrit) event."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.addEvent:3
msgid "This method accepts a JSON-encoded event and simulates Zuul having received it from Gerrit.  It could (and should) eventually apply to any connection type, but is currently only used with Gerrit connections.  The name of the connection is used to look up the corresponding server, and the event is simulated as having been received by all Zuul connections attached to that server.  So if two Gerrit connections in Zuul are connected to the same Gerrit server, and you invoke this method specifying the name of one of them, the event will be received by both."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.addEvent:16
msgid "\"self.fake_gerrit.addEvent\" calls should be migrated to this method."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.addEvent:19
msgid "The name of the connection corresponding to the gerrit server."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.addEvent:21
msgid "The JSON-encoded event."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertBuilds:1
msgid "Assert that the running builds are as described."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertBuilds:3
msgid "The list of running builds is examined and must match exactly the list of builds described by the input."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertBuilds:6
#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertHistory:6
msgid "A list of dictionaries.  Each item in the list must match the corresponding build in the build history, and each element of the dictionary must match the corresponding attribute of the build."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertHistory:1
msgid "Assert that the completed builds are as described."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertHistory:3
msgid "The list of completed builds is examined and must match exactly the list of builds described by the input."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertHistory:11
msgid "If true, the history must match the order supplied, if false, the builds are permitted to have arrived in any order."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:1
msgid "Check statsd output"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:3
msgid "Check statsd return values.  A ``value`` should specify a ``kind``, however a ``kind`` may be specified without a ``value`` for a generic match.  Leave both empy to just check for key presence."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:8
msgid "The statsd key"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:9
msgid "The expected value of the metric ``key``"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:10
msgid "The expected type of the metric ``key``  For example  - ``c`` counter - ``g`` gauge - ``ms`` timing - ``s`` set"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:10
msgid "The expected type of the metric ``key``  For example"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:12
msgid "``c`` counter"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:13
msgid "``g`` gauge"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:14
msgid "``ms`` timing"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:15
msgid "``s`` set"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:17
msgid "How long to wait for the stat to appear"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.assertReportedStat:19
msgid "The value"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.commitConfigUpdate:1
msgid "Commit an update to zuul.yaml"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.commitConfigUpdate:3
msgid "This overwrites the zuul.yaml in the specificed project with the contents specified."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.commitConfigUpdate:6
msgid "The name of the project containing zuul.yaml (e.g., common-config)"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.commitConfigUpdate:9
msgid "The path to the file (underneath the test fixture directory) whose contents should be used to replace zuul.yaml."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.getSortedBuilds:1
msgid "Return the list of currently running builds sorted by name"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.getUpstreamRepos:1
msgid "Return upstream git repo objects for the listed projects"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.FakeBuild.getWorkspaceRepos:3
#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.getUpstreamRepos:3
msgid "A list of strings, each the canonical name of a project."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.FakeBuild.getWorkspaceRepos:6
#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.getUpstreamRepos:6
msgid "A dictionary of {name: repo} for every listed project."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.logState:1
msgid "Log the current state of the system"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.newTenantConfig:1
msgid "Use this to update the tenant config file in tests"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.newTenantConfig:3
msgid "This will update self.tenant_config_file to point to a temporary file for the duration of this particular test. The content of that file will be taken from FIXTURE_DIR/source_name"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.newTenantConfig:7
msgid "After the test the original value of self.tenant_config_file will be restored."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.newTenantConfig:10
msgid "The path of the file under FIXTURE_DIR that will be used to populate the new tenant config file."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.printHistory:1
msgid "Log the build history."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.printHistory:3
msgid "This can be useful during tests to summarize what jobs have completed."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.setUp:1
msgid "Hook method for setting up the test fixture before exercising it."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.ZuulTestCase.waitUntilNodeCacheSync:1
msgid "Wait until the node cache on the zk_nodepool object is in sync"
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of tests.fakegerrit.FakeGerritConnection:1
msgid "A Fake Gerrit connection for use in tests."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of tests.fakegerrit.FakeGerritConnection:3
msgid "This subclasses :py:class:`~zuul.connection.gerrit.GerritConnection` to add the ability for tests to add changes to the fake Gerrit it represents."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of tests.fakegerrit.FakeGerritConnection.addFakeChange:1
msgid "Add a change to the fake Gerrit."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.checkBranchCache:1
msgid "Update the cache for a project when a branch event is processed"
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.checkBranchCache:3
msgid "This method must be called when a branch event is processed: if the event references a branch and the unprotected branches are excluded, the branch protection status could have been changed."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.checkBranchCache:0
msgid "params str project_name"
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.checkBranchCache:8
msgid "The project name."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.checkBranchCache:0
msgid "params event"
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.checkBranchCache:10
#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.clearConnectionCacheOnBranchEvent:9
msgid "The event, inherit from `zuul.model.TriggerEvent` class."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.checkBranchCache:0
msgid "params protected"
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.checkBranchCache:12
msgid "If defined the caller already knows if the branch is protected so the query can be skipped."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKChangeCacheMixin.cleanupCache:1
msgid "Clean up the connection cache."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKChangeCacheMixin.cleanupCache:3
msgid "This allows a connection to perform periodic cleanup actions of the cache, e.g. garbage collection."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.clearBranchCache:1
msgid "Clear the branch cache"
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.clearBranchCache:3
msgid "In case the branch cache gets out of sync with the source, this method can be called to clear it and force querying the source the next time the cache is used."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.clearConnectionCacheOnBranchEvent:1
msgid "Update event and clear connection cache if needed."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.clearConnectionCacheOnBranchEvent:3
msgid "This checks whether the event created or deleted a branch so that Zuul may know to perform a reconfiguration on the project. Drivers must call this method when a branch event is received."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.driver.gerrit.gerritconnection.GerritConnection.getEventQueue:1
msgid "Return the event queue for this connection."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.driver.gerrit.gerritconnection.GerritConnection.getEventQueue:3
msgid "A `zuul.zk.event_queues.ConnectionEventQueue` instance or None."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectBranches:1
msgid "Get the branch names for the given project."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectBranches:3
#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.updateProjectBranches:3
msgid "The project for which the branches are returned."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectBranches:5
#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectDefaultBranch:5
#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectMergeModes:5
msgid "The related tenant."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectBranches:7
#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectDefaultBranch:7
#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectMergeModes:7
msgid "The minimum ltime to determine if we need to refresh the cache."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectBranches:10
msgid "The list of branch names."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectDefaultBranch:1
msgid "Get the default branch for the given project."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectDefaultBranch:3
msgid "The project for which the default branch is returned."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectDefaultBranch:10
msgid "The name of the default branch."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectMergeModes:1
msgid "Get the merge modes for the given project."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectMergeModes:3
msgid "The project for which the merge modes are returned."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.getProjectMergeModes:10
msgid "The list of merge modes by model id."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.BaseConnection.getWebController:1
msgid "Return a cherrypy web controller to register with zuul-web."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.BaseConnection.getWebController:3
msgid "Zuul Web instance."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.BaseConnection.getWebController:5
msgid "A `zuul.web.handler.BaseWebController` instance."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.driver.gerrit.gerritconnection.GerritConnection.isBranchProtected:1
msgid "Return if the branch is protected or None if the branch is unknown."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.driver.gerrit.gerritconnection.GerritConnection.isBranchProtected:3
msgid "The name of the project."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.driver.gerrit.gerritconnection.GerritConnection.isBranchProtected:5
msgid "The name of the branch."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.updateProjectBranches:6
#: ../../../tests/fakegerrit.py:docstring of zuul.driver.gerrit.gerritconnection.GerritConnection.isBranchProtected:8
msgid "Unique id associated to the handled event."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKChangeCacheMixin.maintainCache:1
msgid "Remove stale changes from the cache."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKChangeCacheMixin.maintainCache:3
msgid "This lets the user supply a list of change cache keys that are still in use.  Anything in our cache that isn't in the supplied list and is older than the given max. age (in seconds) should be safe to remove from the cache."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.driver.gerrit.gerritconnection.GerritConnection.toDict:1
msgid "Return public information about the connection"
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.ZKBranchCacheMixin.updateProjectBranches:1
msgid "Update the branch cache for the project."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.BaseConnection.validateWebConfig:1
msgid "Validate web config."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.BaseConnection.validateWebConfig:3
msgid "If there is a fatal error, the method should raise an exception."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.BaseConnection.validateWebConfig:6
msgid "The parsed config object."
msgstr ""

#: ../../../tests/fakegerrit.py:docstring of zuul.connection.BaseConnection.validateWebConfig:8
msgid "Registry of all configured connections."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer:1
msgid "An Ansible executor to be used in tests."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer:3
msgid "If true, when jobs are executed they will report that they have started but then pause until released before reporting completion.  This attribute may be changed at any time and will take effect for subsequently executed builds, but previously held builds will still need to be explicitly released."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.failJob:1
msgid "Instruct the executor to report matching builds as failures."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.failJob:3
#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.retryJob:3
msgid "The name of the job to fail."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.failJob:4
#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.retryJob:4
msgid "The :py:class:`~tests.base.FakeChange` instance which should cause the job to fail.  This job will also fail for changes depending on this change."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.release:1
msgid "Release a held build."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.release:3
msgid "A regular expression which, if supplied, will cause only builds with matching names to be released.  If not supplied, all builds will be released."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.retryJob:1
msgid "Instruct the executor to report matching builds as retries."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.returnData:1
msgid "Instruct the executor to return data for this build."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.returnData:3
msgid "The name of the job to return data."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.returnData:4
msgid "The :py:class:`~tests.base.FakeChange` instance which should cause the job to return data. Or pass a ref as a string."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.RecordingExecutorServer.returnData:7
msgid "The data to return"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.FakeBuild.getWorkspaceRepos:1
msgid "Return workspace git repo objects for the listed projects"
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.FakeBuild.hasChanges:1
msgid "Return whether this build has certain changes in its git repos."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.FakeBuild.hasChanges:3
msgid "One or more changes (varargs) that are expected to be present (in order) in the git repository of the active project."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.FakeBuild.hasChanges:7
msgid "Whether the build has the indicated changes."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.FakeBuild.isWaiting:1
msgid "Return whether this build is being held."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.FakeBuild.isWaiting:3
msgid "Whether the build is being held."
msgstr ""

#: ../../../tests/base.py:docstring of tests.base.FakeBuild.release:1
msgid "Release this build."
msgstr ""

#: ../../source/developer/triggers.rst:2
msgid "Triggers"
msgstr ""

#: ../../source/developer/triggers.rst:4
msgid "Triggers must inherit from :py:class:`~zuul.trigger.BaseTrigger` and, at a minimum, implement the :py:meth:`~zuul.trigger.BaseTrigger.getEventFilters` method."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/trigger/__init__.py:docstring of zuul.trigger.BaseTrigger:1
msgid "Base class for triggers."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/trigger/__init__.py:docstring of zuul.trigger.BaseTrigger:3
msgid "Defines the exact public methods that must be supplied."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/gerrit/gerrittrigger.py:docstring of zuul.driver.gerrit.gerrittrigger.GerritTrigger.getEventFilters:1
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/timer/timertrigger.py:docstring of zuul.driver.timer.timertrigger.TimerTrigger.getEventFilters:1
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/driver/zuul/zuultrigger.py:docstring of zuul.driver.zuul.zuultrigger.ZuulTrigger.getEventFilters:1
#: ../../../../../../../../../../../home/kjh/zuul2/zuul/trigger/__init__.py:docstring of zuul.trigger.BaseTrigger.getEventFilters:1
msgid "Return a list of EventFilter's for the scheduler to match against."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/trigger/__init__.py:docstring of zuul.trigger.BaseTrigger.onChangeEnqueued:1
msgid "Called when a change has been enqueued."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/trigger/__init__.py:docstring of zuul.trigger.BaseTrigger.onChangeMerged:1
msgid "Called when a change has been merged."
msgstr ""

#: ../../../../../../../../../../../home/kjh/zuul2/zuul/trigger/__init__.py:docstring of zuul.trigger.BaseTrigger.postConfig:1
msgid "Called after config is loaded."
msgstr ""

#: ../../source/developer/triggers.rst:10
msgid "Current list of triggers are:"
msgstr ""

#: ../../source/developer/zookeeper.rst:2
msgid "ZooKeeper"
msgstr ""

#: ../../source/developer/zookeeper.rst:5
msgid "Overview"
msgstr ""

#: ../../source/developer/zookeeper.rst:7
msgid "Zuul has a microservices architecture with the goal of no single point of failure in mind."
msgstr ""

#: ../../source/developer/zookeeper.rst:10
msgid "Zuul is an event driven system with several event loops that interact with each other:"
msgstr ""

#: ../../source/developer/zookeeper.rst:13
msgid "Driver event loop: Drivers like GitHub or Gerrit have their own event loops. They perform preprocessing of the received events and add events into the scheduler event loop."
msgstr ""

#: ../../source/developer/zookeeper.rst:17
msgid "Scheduler event loop: This event loop processes the pipelines and reconfigurations."
msgstr ""

#: ../../source/developer/zookeeper.rst:20
msgid "Each of these event loops persists data in ZooKeeper so that other components can share or resume processing."
msgstr ""

#: ../../source/developer/zookeeper.rst:23
msgid "A key aspect of scalability is maintaining an event queue per pipeline. This makes it easy to process several pipelines in parallel. A new driver event is first processed in the driver event queue. This adds a new event into the scheduler event queue. The scheduler event queue then checks which pipeline may be interested in this event according to the tenant configuration and layout. Based on this the event is dispatched to all matching pipeline queues."
msgstr ""

#: ../../source/developer/zookeeper.rst:31
msgid "In order to make reconfigurations efficient we store the parsed branch config in Zookeeper. This makes it possible to create the current layout without the need to ask the mergers multiple times for the configuration. This is used by zuul-web to keep an up-to-date layout for API requests."
msgstr ""

#: ../../source/developer/zookeeper.rst:37
msgid "We store the pipeline state in Zookeeper.  This contains the complete information about queue items, jobs and builds, as well as a separate abbreviated state for quick access by zuul-web for the status page."
msgstr ""

#: ../../source/developer/zookeeper.rst:42
msgid "Driver Event Ingestion"
msgstr ""

#: ../../source/developer/zookeeper.rst:44
msgid "There are three types of event receiving mechanisms in Zuul:"
msgstr ""

#: ../../source/developer/zookeeper.rst:46
msgid "Active event gathering: The connection actively listens to events (Gerrit) or generates them itself (git, timer, zuul)"
msgstr ""

#: ../../source/developer/zookeeper.rst:49
msgid "Passive event gathering: The events are sent to Zuul from outside (GitHub webhooks)"
msgstr ""

#: ../../source/developer/zookeeper.rst:52
msgid "Internal event generation: The events are generated within Zuul itself and typically get injected directly into the scheduler event loop."
msgstr ""

#: ../../source/developer/zookeeper.rst:55
msgid "The active event gathering needs to be handled differently from passive event gathering."
msgstr ""

#: ../../source/developer/zookeeper.rst:59
msgid "Active Event Gathering"
msgstr ""

#: ../../source/developer/zookeeper.rst:61
msgid "This is mainly done by the Gerrit driver. We actively maintain a connection to the target and receive events. We utilize a leader election to make sure there is exactly one instance receiving the events."
msgstr ""

#: ../../source/developer/zookeeper.rst:67
msgid "Passive Event Gathering"
msgstr ""

#: ../../source/developer/zookeeper.rst:69
msgid "In case of passive event gathering the events are sent to Zuul typically via webhooks. These types of events are received in zuul-web which then stores them in Zookeeper. This type of event gathering is used by GitHub and other drivers. In this case we can have multiple instances but still receive only one event so that we don't need to take special care of event deduplication or leader election.  Multiple instances behind a load balancer are safe to use and recommended for such passive event gathering."
msgstr ""

#: ../../source/developer/zookeeper.rst:79
msgid "Configuration Storage"
msgstr ""

#: ../../source/developer/zookeeper.rst:81
msgid "Zookeeper is not designed as a database with a large amount of data, so we should store as little as possible in zookeeper. Thus we only store the per project-branch unparsed config in zookeeper. From this, every part of Zuul, like the scheduler or zuul-web, can quickly recalculate the layout of each tenant and keep it up to date by watching for changes in the unparsed project-branch-config."
msgstr ""

#: ../../source/developer/zookeeper.rst:88
msgid "We store the actual config sharded in multiple nodes, and those nodes are stored under per project and branch znodes. This is needed because of the 1MB limit per znode in zookeeper. It further makes it less expensive to cache the global config in each component as this cache is updated incrementally."
msgstr ""

#: ../../source/developer/zookeeper.rst:95
msgid "Executor and Merger Queues"
msgstr ""

#: ../../source/developer/zookeeper.rst:97
msgid "The executors and mergers each have an execution queue (and in the case of executors, optionally per-zone queues).  This makes it easy for executors and mergers to simply pick the next job to run without needing to inspect the entire pipeline state.  The scheduler is responsible for submitting job requests as the state changes."
msgstr ""

#: ../../source/developer/zookeeper.rst:104
msgid "Zookeeper Map"
msgstr ""

#: ../../source/developer/zookeeper.rst:106
msgid "This is a reference for object layout in Zookeeper."
msgstr ""

#: ../../source/developer/zookeeper.rst:110
msgid "All ephemeral data stored here.  Remove the entire tree to \"reset\" the system."
msgstr ""

#: ../../source/developer/zookeeper.rst:115
msgid "The connection cache root.  Each connection has a dedicated space for its caches.  Two types of caches are currently implemented: change and branch."
msgstr ""

#: ../../source/developer/zookeeper.rst:121
msgid "The connection branch cache root.  Contains the cache itself and a lock."
msgstr ""

#: ../../source/developer/zookeeper.rst:127
msgid "The connection branch cache data.  This is a single sharded JSON blob."
msgstr ""

#: ../../source/developer/zookeeper.rst:132
msgid "The connection branch cache read/write lock."
msgstr ""

#: ../../source/developer/zookeeper.rst:136
msgid "The connection change cache.  Each node under this node is an entry in the change cache.  The node ID is a sha256 of the cache key, the contents are the JSON serialization of the cache entry metadata. One of the included items is the `data_uuid` which is used to retrieve the actual change data."
msgstr ""

#: ../../source/developer/zookeeper.rst:142
msgid "When a cache entry is updated, a new data node is created without deleting the old data node.  They are eventually garbage collected."
msgstr ""

#: ../../source/developer/zookeeper.rst:147
msgid "Data for the change cache.  These nodes are identified by a UUID referenced from the cache entries."
msgstr ""

#: ../../source/developer/zookeeper.rst:150
msgid "These are sharded JSON blobs of the change data."
msgstr ""

#: ../../source/developer/zookeeper.rst:154
msgid "Data for the blob store.  These nodes are identified by a sha256sum of the secret content."
msgstr ""

#: ../../source/developer/zookeeper.rst:157
msgid "These are sharded blobs of data."
msgstr ""

#: ../../source/developer/zookeeper.rst:161
msgid "Side-channel lock directory for the blob store.  The store locks by key id under this znode when writing."
msgstr ""

#: ../../source/developer/zookeeper.rst:166
msgid "This node holds locks for the cleanup routines to make sure that only one scheduler runs them at a time."
msgstr ""

#: ../../source/developer/zookeeper.rst:178
msgid "The component registry.  Each Zuul process registers itself under the appropriate node in this hierarchy so the system has a holistic view of what's running.  The name of the node is based on the hostname but is a sequence node in order to handle multiple processes.  The nodes are ephemeral so an outage is automatically detected."
msgstr ""

#: ../../source/developer/zookeeper.rst:185
msgid "The contents of each node contain information about the running process and may be updated periodically."
msgstr ""

#: ../../source/developer/zookeeper.rst:196
msgid "The unparsed config cache.  This contains the contents of every Zuul config file returned by the mergers for use in configuration. Organized by repo canonical name, branch, and filename.  The files themselves are sharded."
msgstr ""

#: ../../source/developer/zookeeper.rst:203
msgid "Locks for the unparsed config cache."
msgstr ""

#: ../../source/developer/zookeeper.rst:208
msgid "The connection event queue root.  Each connection has an event queue where incoming events are recorded before being moved to the tenant event queue."
msgstr ""

#: ../../source/developer/zookeeper.rst:214
msgid "The actual event queue.  Entries in the queue reference separate data nodes.  These are sequence nodes to maintain the event order."
msgstr ""

#: ../../source/developer/zookeeper.rst:219
msgid "Event data nodes referenced by queue items.  These are sharded."
msgstr ""

#: ../../source/developer/zookeeper.rst:223
msgid "An election to determine which scheduler processes the event queue and moves events to the tenant event queues."
msgstr ""

#: ../../source/developer/zookeeper.rst:226
msgid "Drivers may have additional elections as well.  For example, Gerrit has an election for the watcher and poller."
msgstr ""

#: ../../source/developer/zookeeper.rst:231
msgid "Tenant-specific event queues.  Each queue described below has a data and queue subnode."
msgstr ""

#: ../../source/developer/zookeeper.rst:236
msgid "The tenant-specific management event queue."
msgstr ""

#: ../../source/developer/zookeeper.rst:240
msgid "The tenant-specific trigger event queue."
msgstr ""

#: ../../source/developer/zookeeper.rst:244
msgid "Holds a set of queues for each pipeline."
msgstr ""

#: ../../source/developer/zookeeper.rst:248
msgid "The pipeline management event queue."
msgstr ""

#: ../../source/developer/zookeeper.rst:252
msgid "The pipeline result event queue."
msgstr ""

#: ../../source/developer/zookeeper.rst:256
msgid "The pipeline trigger event queue."
msgstr ""

#: ../../source/developer/zookeeper.rst:260
msgid "A Znode that, if exists, can be used to pause event processing."
msgstr ""

#: ../../source/developer/zookeeper.rst:266
msgid "The unzoned executor build request queue.  The generic description of a job request queue follows:"
msgstr ""

#: ../../source/developer/zookeeper.rst:271
msgid "Requests are added by UUID.  Consumers watch the entire tree and order the requests by znode creation time."
msgstr ""

#: ../../source/developer/zookeeper.rst:277
msgid "A consumer will create a lock under this node before processing a request.  The znode containing the lock and the request znode have the same UUID.  This is a side-channel lock so that the lock can be held while the request itself is deleted."
msgstr ""

#: ../../source/developer/zookeeper.rst:284
msgid "Parameters can be quite large, so they are kept in a separate znode and only read when needed, and may be removed during request processing to save space in ZooKeeper.  The data may be sharded."
msgstr ""

#: ../../source/developer/zookeeper.rst:291
msgid "When a job is complete, the results of the merge are written here.  The results may be quite large, so they are sharded."
msgstr ""

#: ../../source/developer/zookeeper.rst:296
msgid "Since writing sharded data is not atomic, once the results are written to ``result-data``, a small znode is written here to indicate the results are ready to read.  The submitter can watch this znode to be notified that it is ready."
msgstr ""

#: ../../source/developer/zookeeper.rst:304
msgid "A submitter who requires the results of the job creates an ephemeral node here to indicate their interest in the results. This is used by the cleanup routines to ensure that they don't prematurely delete the result data.  Used for merge jobs"
msgstr ""

#: ../../source/developer/zookeeper.rst:311
msgid "A zone-specific executor build request queue.  The contents are the same as above."
msgstr ""

#: ../../source/developer/zookeeper.rst:317
msgid "An election to decide which launcher will report system-wide launcher stats (such as total nodes)."
msgstr ""

#: ../../source/developer/zookeeper.rst:322
msgid "The layout state for the tenant.  Contains the cache and time data needed for a component to determine if its in-memory layout is out of date and update it if so."
msgstr ""

#: ../../source/developer/zookeeper.rst:328
msgid "Additional information about the layout.  This is sharded data for each layout UUID."
msgstr ""

#: ../../source/developer/zookeeper.rst:333
msgid "Holds various types of locks so that multiple components can coordinate."
msgstr ""

#: ../../source/developer/zookeeper.rst:337
msgid "Locks related to connections."
msgstr ""

#: ../../source/developer/zookeeper.rst:341
msgid "Locks related to a single connection."
msgstr ""

#: ../../source/developer/zookeeper.rst:346
msgid "Only one component should run a database migration; this lock ensures that."
msgstr ""

#: ../../source/developer/zookeeper.rst:351
msgid "Locks related to tenant event queues."
msgstr ""

#: ../../source/developer/zookeeper.rst:356
msgid "The scheduler locks the trigger event queue for each tenant before processing it.  This lock is only needed when processing and removing items from the queue; no lock is required to add items."
msgstr ""

#: ../../source/developer/zookeeper.rst:363
msgid "The scheduler locks the management event queue for each tenant before processing it.  This lock is only needed when processing and removing items from the queue; no lock is required to add items."
msgstr ""

#: ../../source/developer/zookeeper.rst:369
msgid "Locks related to pipelines."
msgstr ""

#: ../../source/developer/zookeeper.rst:374
msgid "The scheduler obtains a lock before processing each pipeline."
msgstr ""

#: ../../source/developer/zookeeper.rst:378
msgid "Tenant configuration locks."
msgstr ""

#: ../../source/developer/zookeeper.rst:383
msgid "A write lock is obtained at this location before creating a new tenant layout and storing its metadata in ZooKeeper.  Components which later determine that they need to update their tenant configuration to match the state in ZooKeeper will obtain a read lock at this location to ensure the state isn't mutated again while the components are updating their layout to match."
msgstr ""

#: ../../source/developer/zookeeper.rst:392
msgid "An empty node which serves to coordinate logical timestamps across the cluster.  Components may update this znode which will cause the latest ZooKeeper transaction ID to appear in the zstat for this znode.  This is known as the `ltime` and can be used to communicate that any subsequent transactions have occurred after this `ltime`. This is frequently used for cache validation.  Any cache which was updated after a specified `ltime` may be determined to be sufficiently up-to-date for use without invalidation."
msgstr ""

#: ../../source/developer/zookeeper.rst:404
msgid "A JobRequestQueue for mergers.  See :path:`zuul/executor/unzoned`."
msgstr ""

#: ../../source/developer/zookeeper.rst:409
msgid "An election to decide which scheduler will monitor nodepool requests and generate node completion events as they are completed."
msgstr ""

#: ../../source/developer/zookeeper.rst:414
msgid "Stores results from management events (such as an enqueue event)."
msgstr ""

#: ../../source/developer/zookeeper.rst:419
msgid "An election to decide which scheduler will generate events for timer pipeline triggers."
msgstr ""

#: ../../source/developer/zookeeper.rst:425
msgid "An election to decide which scheduler will report system-wide stats (such as total node requests)."
msgstr ""

#: ../../source/developer/zookeeper.rst:431
msgid "Represents a global semaphore (shared by multiple tenants). Information about which builds hold the semaphore is stored in the znode data."
msgstr ""

#: ../../source/developer/zookeeper.rst:438
msgid "Represents a semaphore.  Information about which builds hold the semaphore is stored in the znode data."
msgstr ""

#: ../../source/developer/zookeeper.rst:444
msgid "System-wide configuration data."
msgstr ""

#: ../../source/developer/zookeeper.rst:448
msgid "The serialized version of the unparsed abide configuration as well as system attributes (such as the tenant list)."
msgstr ""

#: ../../source/developer/zookeeper.rst:454
msgid "A lock to be acquired before updating :path:`zuul/system/conf`"
msgstr ""

#: ../../source/developer/zookeeper.rst:458
msgid "Tenant-specific information here."
msgstr ""

#: ../../source/developer/zookeeper.rst:462
msgid "Pipeline state."
msgstr ""

#: ../../source/developer/zookeeper.rst:466
msgid "A flag indicating that the pipeline state is \"dirty\"; i.e., it needs to have the pipeline processor run."
msgstr ""

#: ../../source/developer/zookeeper.rst:471
msgid "Holds queue objects."
msgstr ""

#: ../../source/developer/zookeeper.rst:475
msgid "Items belong to queues, but are held in their own hierarchy since they may shift to different queues during reconfiguration."
msgstr ""

#: ../../source/developer/zookeeper.rst:480
msgid "There will only be one buildset under the buildset/ node.  If we reset it, we will get a new uuid and delete the old one.  Any external references to it will be automatically invalidated."
msgstr ""

#: ../../source/developer/zookeeper.rst:486
msgid "The global repo state for the buildset is kept in its own node since it can be large, and is also common for all jobs in this buildset."
msgstr ""

#: ../../source/developer/zookeeper.rst:492
msgid "The frozen job."
msgstr ""

#: ../../source/developer/zookeeper.rst:496
msgid "Information about this build of the job.  Similar to buildset, there should only be one entry, and using the UUID automatically invalidates any references."
msgstr ""

#: ../../source/developer/zookeeper.rst:502
msgid "Parameters for the build; these can be large so they're in their own znode and will be read only if needed."
msgstr ""

#: ../../source/developer/zookeeper.rst:508
msgid "A new-style (nodepool-in-zuul) node request.  This will replace `nodepool/requests`.  The two may operate in parallel for a time."
msgstr ""

#: ../../source/developer/zookeeper.rst:511
msgid "Schedulers create requests and may delete them at any time (regardless of lock state)."
msgstr ""

#: ../../source/developer/zookeeper.rst:516
msgid "A lock for the new-style node request.  Launchers will acquire a lock when operating on the request."
msgstr ""

#: ../../source/developer/zookeeper.rst:522
msgid "A new-style (nodepool-in-zuul) node record.  This holds information about the node (mostly supplied by the provider).  It also holds enough information to get the endpoint responsible for the node."
msgstr ""

#: ../../source/developer/zookeeper.rst:529
msgid "Information about a provider node snapshot.  The launcher locks the companion snapshot-lock znode and updates this znode while the executor continues to hold the lock on the main node's znode."
msgstr ""

#: ../../source/developer/zookeeper.rst:535
msgid "The lock for the snapshot child znode."
msgstr ""

#: ../../source/developer/zookeeper.rst:539
msgid "A lock for the new-style node.  Launchers or executors will hold this lock while operating on the node."
msgstr ""

#: ../../source/developer/zookeeper.rst:544
msgid "The flattened configuration for a provider.  This holds the complete information about the images, labels, and flavors the provider supports.  It is the combination of the provider stanza plus any inherited sections."
msgstr ""

#: ../../source/developer/zookeeper.rst:549
msgid "References to images, labels, and flavors are made using canonical names since the same short names may be different in different tenants.  Since the same canonically-named provider may appear in different tenants with different images, labels, and flavors, the provider itself is tenant scoped."
msgstr ""

#: ../../source/developer/zookeeper.rst:555
msgid "Only updated by schedulers upon reconfiguration.  Read-only for launchers."
msgstr ""

#: ../../source/developer/zookeeper.rst:559
msgid "Stores information about an image build artifact.  Each build job may produce any number of artifacts (each corresponding to an image+format).  Information about each is stored here under a random uuid."
msgstr ""

#: ../../source/developer/zookeeper.rst:566
msgid "Stores information about an image upload to a particular cloud endpoint."
msgstr ""

#: ../../source/developer/zookeeper.rst:571
msgid "A TreeCache that stores quota information for the endpoint."
msgstr ""

#: ../../source/developer/zookeeper.rst:575
msgid "Stores information about the quota limits of the endpoint."
msgstr ""

#: ../../source/developer/zookeeper.rst:579
msgid "Stores information about the unmanaged quota usage of the endpoint."
msgstr ""

#: ../../source/developer/zookeeper.rst:583
msgid "Stores information about the quota requirements of driver-defined resources (such as instance or volume types).  This allows any launcher to calculate the estimated quota usage of any request, without having an active endpoint."
msgstr ""
