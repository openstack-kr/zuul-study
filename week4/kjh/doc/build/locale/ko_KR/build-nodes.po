# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2026, Zuul project contributors
# This file is distributed under the same license as the Zuul package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Zuul latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-09 11:00+0900\n"
"PO-Revision-Date: 2026-02-09 11:58+0900\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko_KR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.8\n"

#: ../../source/build-nodes.rst:6
msgid "Build Nodes"
msgstr "빌드 노드(Build Nodes)"

#: ../../source/build-nodes.rst:8
msgid ""
"Zuul previously used a companion program, Nodepool, to manage build nodes.  "
"Nodepool is deprecated and its usage should be replaced by the system "
"described here."
msgstr ""
"Zuul은 이전에 빌드 노드를 관리하기 위해 보조 프로그램인 Nodepool을 사용했다. "
"Nodepool은 현재 사용 중단(deprecated)되었으며, 여기에서 설명하는 시스템으로 "
"대체되어야 한다."

#: ../../source/build-nodes.rst:12
msgid ""
"Zuul manages resources for builds (such as virtual machines from a cloud, "
"Kubernetes pods, or static hosts), known as `build nodes` or simply `nodes`, "
"using the same configuration system used for jobs and pipelines.  Because "
"Zuul is interacting with remote systems and causing real resource usage "
"(which may come at a cost), there are some differences, but most of the "
"configuration is contained in git repositories and control of this "
"configuration can be retained by the administrators of a Zuul system or "
"delegated to its users."
msgstr ""
"Zuul은 클라우드의 가상 머신, Kubernetes 파드, 또는 정적 호스트와 같은 빌드용 "
"리소스를 `build nodes`(또는 간단히 `nodes`)라고 부르며, job과 파이프라인에 사"
"용되는 것과 동일한 설정 시스템을 통해 관리한다. Zuul은 원격 시스템과 상호 작"
"용하며 실제 리소스를 사용하기 때문에(비용이 발생할 수 있음) 몇 가지 차이점이 "
"존재하지만, 대부분의 설정은 Git 저장소에 포함되며 Zuul 시스템 관리자에 의해 "
"관리되거나 사용자에게 위임될 수 있다."

#: ../../source/build-nodes.rst:21
msgid ""
"Zuul has a dedicated component, the `zuul-launcher` which manages the "
"lifecycle of build nodes.  Additionally, it can manage the building of "
"custom virtual machine images that are used for them."
msgstr ""
"Zuul에는 빌드 노드의 생명 주기를 관리하는 전용 컴포넌트인 `zuul-launcher`가 "
"있다. 또한 빌드 노드에 사용되는 사용자 정의 가상 머신 이미지의 빌드도 관리할 "
"수 있다."

#: ../../source/build-nodes.rst:25
msgid ""
"There are a number of Zuul configuration objects that are related to node "
"and image management:"
msgstr "노드 및 이미지 관리와 관련된 여러 Zuul 설정 객체가 있다:"

#: ../../source/build-nodes.rst:28
msgid ":ref:`provider`"
msgstr ":ref:`provider`"

#: ../../source/build-nodes.rst:29
msgid ":ref:`section`"
msgstr ":ref:`section`"

#: ../../source/build-nodes.rst:30
msgid ":ref:`label`"
msgstr ":ref:`label`"

#: ../../source/build-nodes.rst:31
msgid ":ref:`flavor`"
msgstr ":ref:`flavor`"

#: ../../source/build-nodes.rst:32
msgid ":ref:`image`"
msgstr ":ref:`image`"

#: ../../source/build-nodes.rst:34
msgid ""
"The :ref:`provider` object is the main configuration object related node and "
"image management.  It may represent a Kubernetes cluster, or a region of a "
"cloud, or a collection of static nodes, any of which are made available to a "
"tenant.  If you use more than one cloud, or region of a cloud, you will have "
"at least one provider for each cloud or region.  If you have tenants which "
"should share a cloud region, then you may put that provider in both "
"tenants.  If they should not share cloud resources, then you may create a "
"unique provider in each tenant."
msgstr ""
":ref:`provider` 객체는 노드 및 이미지 관리와 관련된 핵심 설정 객체이다. 이는 "
"Kubernetes 클러스터, 클라우드의 특정 리전, 또는 정적 노드의 집합을 나타낼 수 "
"있으며, 이러한 리소스는 tenant에 제공된다. 하나 이상의 클라우드나 클라우드 리"
"전을 사용하는 경우, 각 클라우드 또는 리전마다 최소 하나의 provider가 필요하"
"다. 여러 tenant가 동일한 클라우드 리전을 공유해야 한다면 해당 provider를 여"
"러 tenant에 포함시킬 수 있고, 리소스를 공유해서는 안 된다면 tenant별로 고유"
"한 provider를 생성할 수 있다."

#: ../../source/build-nodes.rst:43
msgid ""
"The :ref:`section` object is a flexible system of configuration related to "
"providers to facilitate all of these different options.  A section represent "
"a portion of a provider (such as a cloud region).  A provider builds its "
"configuration by inheriting from a section. Sections may inherit from "
"another section, so many layers of abstraction may be accommodated."
msgstr ""
":ref:`section` 객체는 provider와 관련된 다양한 구성을 유연하게 표현하기 위한 "
"설정 시스템이다. section은 provider의 일부(예: 클라우드 리전)를 나타낸다. "
"provider는 section으로부터 설정을 상속받아 구성되며, section은 또 다른 "
"section을 상속할 수 있어 여러 단계의 추상화를 구성할 수 있다."

#: ../../source/build-nodes.rst:50
msgid ""
"Ultimately, a section is associated with one Zuul :ref:`connection "
"<connections>`, which is how the actual authenticated connection to the "
"cloud is made.  Consider the following example of how to structure sections "
"and providers:"
msgstr ""
"궁극적으로 section은 하나의 Zuul :ref:`connection <connections>`과 연결되며, "
"이를 통해 클라우드에 대한 실제 인증된 연결이 이루어진다. 다음은 section과 "
"provider를 구성하는 방법에 대한 예시이다:"

#: ../../source/build-nodes.rst:98
msgid ""
"This shows a system with three providers.  Two of the providers use the eu-"
"north-1 region, one of them uses eu-central-1.  Those sections both inherit "
"from a single section named `aws`, which in turn references the `aws` "
"connection.  The `aws` section can be used to configure settings that are "
"universally applicable to AWS.  The `north` and `central` sections may add "
"settings applicable to just those regions, and finally, the providers can "
"further refine settings."
msgstr ""
"이 예시는 세 개의 provider로 구성된 시스템을 보여준다. 이 중 두 개의 provider"
"는 eu-north-1 리전을 사용하고, 하나는 eu-central-1 리전을 사용한다. 이들 "
"section은 모두 `aws`라는 단일 section을 상속하며, 해당 section은 `aws` "
"connection을 참조한다. `aws` section은 AWS 전반에 공통으로 적용되는 설정을 구"
"성하는 데 사용되며, `north`와 `central` section은 각 리전에만 적용되는 설정"
"을 추가할 수 있다. 마지막으로 provider는 이러한 설정을 기반으로 추가적인 세"
"부 조정을 할 수 있다."

#: ../../source/build-nodes.rst:107
msgid "Node Reuse"
msgstr "노드 재사용(Node Reuse)"

#: ../../source/build-nodes.rst:109
msgid ""
"In general, the assumption is that Zuul will create a node, use it once for "
"one build of a job, and then delete the node after the completion of the "
"build.  Depending on the driver, it may be possible to configure Zuul to re-"
"use nodes, using the ``reuse`` option.  If this is set, then nodes will be "
"returned to service after the completion of a build.  Note that this option "
"can be dangerous since a job may have compromised the security of the node, "
"and could obtain information or credentials from jobs that subsequently run "
"on it. This behavior is automatically enabled (and can not be disabled) by "
"the static driver."
msgstr ""
"일반적으로 Zuul은 노드를 생성한 후 하나의 job 빌드에 한 번 사용하고, 빌드가 "
"완료되면 해당 노드를 삭제하는 것을 기본 동작으로 한다. 드라이버에 따라 "
"``reuse`` 옵션을 사용하여 노드를 재사용하도록 Zuul을 설정할 수 있다. 이 옵션"
"이 설정되면, 노드는 빌드 완료 후 다시 서비스에 투입된다. 그러나 이 옵션은 보"
"안상 위험할 수 있는데, 이전 job이 노드의 보안을 침해했을 경우 이후에 실행되"
"는 job이 정보나 자격 증명을 획득할 수 있기 때문이다. static 드라이버에서는 "
"이 동작이 자동으로 활성화되며 비활성화할 수 없다."

#: ../../source/build-nodes.rst:120
msgid ""
"A related option is the ``slots`` option, which configures how many builds "
"may run on a node simultaneously.  If set to a value greater than ``1``, "
"then a single underlying node (VM, static host, etc) will serve as host to "
"multiple sub-nodes in Zuul, each of which can be used by a different build "
"simultaneously.  This has similar security implications as ``reuse``, so "
"care should be taken when using it."
msgstr ""
"관련 옵션으로 ``slots`` 옵션이 있으며, 이는 하나의 노드에서 동시에 실행될 수 "
"있는 빌드의 수를 설정한다. ``1``보다 큰 값으로 설정할 경우, 하나의 기본 노드"
"(VM, 정적 호스트 등)가 Zuul에서 여러 하위 노드의 호스트 역할을 하게 되며, 각"
"각은 서로 다른 빌드에서 동시에 사용될 수 있다. 이는 ``reuse`` 옵션과 유사한 "
"보안 영향을 가지므로 사용 시 주의가 필요하다."

#: ../../source/build-nodes.rst:127
msgid ""
"The combination of ``reuse`` and ``slots`` enables similar functionality to "
"the ``metastatic`` Nodepool driver."
msgstr ""
"``reuse``와 ``slots`` 옵션을 함께 사용하면 Nodepool의 ``metastatic`` 드라이버"
"와 유사한 기능을 제공할 수 있다."

#: ../../source/build-nodes.rst:133
msgid "Image Creation"
msgstr "이미지 생성(Image Creation)"

#: ../../source/build-nodes.rst:135
msgid ""
"Normal Zuul jobs can be used to build an image, and then Zuul can upload the "
"resulting file (qcow2, vhd, etc) to a cloud for use in launching nodes."
msgstr ""
"일반 Zuul job을 사용하여 이미지를 빌드할 수 있으며, Zuul은 생성된 파일(qcow2, "
"vhd 등)을 클라우드에 업로드하여 노드 실행에 사용할 수 있다."

#: ../../source/build-nodes.rst:139
msgid ""
"Image build jobs must run in a pipeline with a special reporter.  The "
"pipeline may be triggered by any of the usual triggers, but a special "
"trigger for missing image builds is also available.  The reporter "
"configuration required for image builds is this:"
msgstr ""
"이미지 빌드 job은 특별한 reporter가 설정된 파이프라인에서 실행되어야 한다. 해"
"당 파이프라인은 일반적인 트리거로 실행될 수 있으며, 누락된 이미지 빌드를 위"
"한 전용 트리거도 사용할 수 있다. 이미지 빌드에 필요한 reporter 설정은 다음과 "
"같다:"

#: ../../source/build-nodes.rst:152
msgid "(See below for more about ``image-validated``)."
msgstr "(``image-validated``에 대한 자세한 내용은 아래를 참조한다.)"

#: ../../source/build-nodes.rst:154
msgid ""
"The trigger configuration that will cause Zuul to run a build for a missing "
"image is:"
msgstr ""
"다음은 누락된 이미지에 대해 Zuul이 빌드를 실행하도록 하는 트리거 설정이다:"

#: ../../source/build-nodes.rst:164
msgid ""
"To tell Zuul a job is an image build job, use the :attr:`job.image-name` "
"attribute to indicate to Zuul that job is used to build an image with that "
"name.  The name must match a :ref:`image` object, and the job must be "
"defined in the same repository as the image object.  The job is responsible "
"for building the image and uploading it to an object storage system.  It "
"must return information about where the image is stored "
"using :ref:`return_values`.  Here is an example `zuul_return` stanza showing "
"the expected information for a qcow2 image:"
msgstr ""
"job이 이미지 빌드 job임을 Zuul에 알리기 위해 :attr:`job.image-name` 속성을 사"
"용하여 해당 job이 지정된 이름의 이미지를 빌드함을 명시한다. 이 이름"
"은 :ref:`image` 객체와 일치해야 하며, job은 이미지 객체와 동일한 저장소에 정"
"의되어야 한다. 해당 job은 이미지를 빌드하고 이를 오브젝트 스토리지 시스템에 "
"업로드할 책임이 있다. 또한 :ref:`return_values`를 사용하여 이미지가 저장된 위"
"치에 대한 정보를 반환해야 한다. 다음은 qcow2 이미지에 대해 기대되는 정보를 보"
"여주는 `zuul_return` 설정 예시이다:"

#: ../../source/build-nodes.rst:190
msgid ""
"Drivers may implement a number of methods for handling images.  Most of them "
"can handle the simple case where the build job uploads the image to an "
"object storage system accessible over HTTP, and the driver will download the "
"file and then upload it to the cloud.  Some drivers support a configuration "
"where the image is uploaded to the cloud's object storage system by the job, "
"and then Zuul can directly import the file into the cloud as an image.  See "
"the individual driver documentation for details."
msgstr ""
"드라이버는 이미지를 처리하기 위한 여러 가지 방법을 구현할 수 있다. 대부분의 "
"드라이버는 빌드 job이 HTTP로 접근 가능한 오브젝트 스토리지에 이미지를 업로드"
"하면, 드라이버가 이를 다운로드한 후 클라우드에 업로드하는 단순한 방식을 지원"
"한다. 일부 드라이버는 job이 클라우드의 오브젝트 스토리지 시스템에 직접 이미지"
"를 업로드하고, Zuul이 이를 이미지로 바로 가져오는 구성을 지원한다. 자세한 내"
"용은 각 드라이버의 문서를 참조하라."

#: ../../source/build-nodes.rst:199
msgid ""
"In addition to building image artifacts, some drivers also support snapshot-"
"based image builds.  In this case, the image build job should manipulate the "
"node it is running on, and when the node is ready for the snapshot to be "
"taken, it should execute this task at the end of the `run` playbook to tell "
"Zuul to perform the snapshot:"
msgstr ""
"이미지 아티팩트를 생성하는 방식 외에도, 일부 드라이버는 스냅샷 기반 이미지 빌"
"드를 지원한다. 이 경우 이미지 빌드 job은 실행 중인 노드를 설정한 뒤, 스냅샷"
"을 생성할 준비가 되면 `run` 플레이북의 마지막 단계에서 해당 작업을 실행하여 "
"Zuul에 스냅샷 생성을 요청해야 한다:"

#: ../../source/build-nodes.rst:215
msgid ""
"Control will return to Zuul, the snapshot will be taken, then the `post-run` "
"playbooks will run as normal."
msgstr ""
"이후 제어는 Zuul로 돌아가며, 스냅샷이 생성된 다음 `post-run` 플레이북이 정상"
"적으로 실행된다."

#: ../../source/build-nodes.rst:219
msgid "Image Validation"
msgstr "이미지 검증(Image Validation)"

#: ../../source/build-nodes.rst:221
msgid ""
"Zuul may be configured to run validation jobs on an image after the image is "
"made available in the cloud, but before it is used for any normal Zuul "
"builds.  To configure this, omit the ``image-validated`` field in the image "
"build pipeline.  Then create a new pipeline just for image validation.  It "
"should look like this:"
msgstr ""
"Zuul은 이미지가 클라우드에 사용 가능 상태가 된 이후, 일반 Zuul 빌드에 사용되"
"기 전에 해당 이미지에 대해 검증 job을 실행하도록 설정할 수 있다. 이를 위해 이"
"미지 빌드 파이프라인에서 ``image-validated`` 필드를 생략하고, 이미지 검증만"
"을 위한 새로운 파이프라인을 생성한다. 구성은 다음과 같다:"

#: ../../source/build-nodes.rst:239
msgid ""
"Then attach jobs to the new `image-validate` pipeline.  If those jobs pass, "
"the image will be considered validated and placed into service. If they "
"fail, the image will be deleted."
msgstr ""
"그 다음 새로운 `image-validate` 파이프라인에 job을 연결한다. 해당 job들이 성공"
"하면 이미지는 검증된 것으로 간주되어 서비스에 투입되며, 실패할 경우 이미지는 "
"삭제된다."

#: ../../source/build-nodes.rst:244
msgid "Nodepool Migration"
msgstr "Nodepool 마이그레이션(Nodepool Migration)"

#: ../../source/build-nodes.rst:246
msgid ""
"Zuul previously used the companion program Nodepool to manage the lifecycle "
"of nodes and images.  The new system managed by `zuul-launcher` is designed "
"to provide a seamless migration.  When Zuul prepares to run a job and needs "
"to obtain a node of a certain label, it will first check to see if that "
"label is defined by a :attr:`label` object in the current tenant.  If it is, "
"then it will be provided by the new `zuul-launcher` system.  If not, it will "
"fall back on Nodepool.  With this behavior, a Zuul system may be migrated "
"from Nodepool one tenant and one label at a time."
msgstr ""
"Zuul은 이전에 Nodepool이라는 보조 프로그램을 사용하여 노드와 이미지의 생명 주"
"기를 관리했다. `zuul-launcher`가 관리하는 새로운 시스템은 이러한 환경을 매끄"
"럽게 마이그레이션할 수 있도록 설계되었다. Zuul이 job을 실행하기 위해 특정 "
"label의 노드를 필요로 할 때, 먼저 현재 tenant에 해당 label이 :attr:`label` 객"
"체로 정의되어 있는지 확인한다. 정의되어 있다면 새로운 `zuul-launcher` 시스템"
"을 통해 노드가 제공되고, 그렇지 않다면 Nodepool로 폴백된다. 이 동작을 통해 "
"Zuul 시스템은 tenant 및 label 단위로 점진적인 마이그레이션이 가능하다."

#: ../../source/build-nodes.rst:256
msgid ""
"Once a tenant is completely migrated, the :attr:`tenant.use-nodepool` "
"setting should be set to ``false`` to disable the Nodepool fallback "
"behavior, and a void a situation where Zuul submits a request to Nodepool "
"when it is not running."
msgstr ""
"tenant가 완전히 마이그레이션되면 :attr:`tenant.use-nodepool` 설정을 ``false``"
"로 지정하여 Nodepool 폴백 동작을 비활성화해야 한다. 이를 통해 Nodepool이 실"
"행 중이지 않은 상태에서 Zuul이 Nodepool에 요청을 보내는 상황을 방지할 수 있"
"다."
