zuul-study week2 노성은
=====================

  [전체 내용 정리 페이지] 

  : https://www.notion.so/CI-CD-OpenStack-Zuul-2f437a3845a7809dba2cd8842af4fb46?source=copy_link

  [week2 수행 내용]

  : CI/CD, OpenStack, Zuul에 대한 이해를 위해 자료를 찾아보고, 정리하며 학습해보았다.

  [참고 문헌]

  https://aws.amazon.com/ko/what-is/ci-cd/
  https://it.donga.com/101955/
  https://docs.openstack.org/ko_KR/
  https://www.openstack.org/software/
  https://www.fortinet.com/kr/resources/cyberglossary/openstack
  https://wikidocs.net/229965](https://wikidocs.net/229965
  https://docs.openstack.org/contributors/ko_KR/common/zuul-status.html
  https://zuul-ci.org/docs/zuul/latest/

|

.. contents:: 목차
   :depth: 4
   :local:

CI/CD, OpenStack, Zuul 에 대한 이해 - 요약
-------------------

a. CI CD
~~~~~~~~

**[CI/CD란?]**
^^^^^^^^^^^^^^^^^^

* CI/CD는 애플리케이션의 개발부터 배포까지 모든 단계를 자동화하여 , 사용자에게 빈번하고 안정적으로 서비스를 제공하는 소프트웨어 개발 전략이자 프로세스이다.

  - 코드 작성, 빌드, 테스트, 배포에 이르는 과정을 파이프라인으로 구축하여 개발 효율성과 소프트웨어 품질을 동시에 높이는 것을 목적으로 한다.
  - 개발팀이 코드 변경 사항을 더 자주, 더 빨리, 더 안정적으로 운영 환경에 적용할 수 있도록 지원한다.
  - 소프트웨어 제공 워크플로를 간소화하여 복잡성을 감소시키고, 대규모 환경에서의 효율성을 향상시킨다. 일부 개발팀은 하루에도 여러 차례 변경 사항을 배포하여, 사용자가 지속적으로 개선되는 애플리케이션을 경험할 수 있도록 한다.

* **CI/CD 파이프라인 프로세스**

  - ‘코드 커밋 → 빌드 → 테스트 → 배포’의 자동화

    1. **Code Push**
    2. **Trigger & CI**
    3. **Feedback & Merge**
    4. 메인 브랜치 병합 후 최종 빌드 및 테스트가 완료되면, CI 파이프라인이 실행 되어 프로덕션 환경에 변경사항을 자동으로 배포한다.



**[CI/CD의 장점]**
^^^^^^^^^^^^^^^^^^^

* **기능 릴리스 가속화 및 효율성 증대**

  - 개발 프로세스 간소화
  - 빈번한 배포 및 피드백
  - 핸드오프 손실 방지
  - 경쟁 우위 확보

* **소프트웨어 품질 개선 및 테스트 자동화**

  - 탁월한 코드 품질 보장
  - 신속한 오류 해결
  - 소규모 업데이트의 이점
  - 릴리스 지연 방지

* **개발자 경험 강화 및 업무 만족도 향상**

  - 반복 작업 제거
  - 가치 있는 작업에 집중
  - 백로그 감소
  - 팀 사기 진작

* **오류 격리 및 간소화된 복구 (MTTR 개선)**

  - 오류 격리
  - 간소화된 롤백
  - MTTR(평균 해결 시간) 개선

* **투명성, 책임성 및 데이터 모니터링**

  - 싱글 윈도우(Single Window)
  - 예측 가능한 마일스톤
  - 지표(Metrics) 활용


**[CI/CD의 작동 방식]**
^^^^^^^^^^^^^^^^^^^^^^

* CI/CD는 구축 및 배포 프로세스를 자동화하여 애플리케이션 개발 주기와 소프트웨어 업데이트를 가속화한다.
* 또한, 투명하고 확장 가능한 최신 소프트웨어 개발 관행에서 더 빠른 피드백을 가능하게 하여 개발 팀과 운영 팀 간의 격차를 해소한다.

* **지속적 통합 (Continuous Integration)**

  - 개발자가 공유 코드 리포지토리의 변경 사항을 통합하는 방식을 자동화한다.
  - 저장소는 성공적인 빌드를 위한 소스 코드, 라이브러리, 테스트 스크립트 및 기타 리소스로 구성된다.
  - 지속적 통합을 통해 개발자는 품질 저하 없이 코드를 더 자주 제공할 수 있다.
  - 기존에 합의된 시간까지 기다려야 했던 방식에서 발생하던 코드 충돌(한 개발자의 변경이 다른 부분에 오류를 일으키는 현상) 문제를 해결하며, 여러 개발자가 동시에 작업해도 다른 사람의 코드를 손상시키지 않아 코드 릴리스가 더 빨라진다.

* **지속적 전달 (Continuous Delivery)**

  - 지속적 통합 단계에서 검증된 코드를 프로덕션 배포에 사용할 준비가 되도록 한다.
  - CI 단계 이후, 단위, 통합, 회귀, API 안정성 테스트 등 추가 자동 테스트를 거친다.
  - 테스트를 통해 문제를 조기에 식별하고, 문제가 있는 코드를 재작업할 수 있다.
  - 검증 완료 후 서버리스 리소스, 클라우드 서버 등 인프라를 자동으로 프로비저닝한다.
  - 운영 팀이 프로덕션 환경에 애플리케이션을 **수동으로 배포**할 수 있는 상태가 된다.

* **지속적 배포 (Continuous Deployment)**

  - 배포 단계에서 사람의 수동 개입을 제거하여 코드 자동화를 더욱 발전시킨다.
  - 자동화된 테스트 도구를 사용하여 고품질 소프트웨어를 생성한다.
  - 운영 팀의 승인을 기다리는 대신, 설정된 애플리케이션 승인 기준을 통과하면 최종 사용자에게 **자동으로 배포**된다.



**[기존의 CI/CD 툴]**
^^^^^^^^^^^^^^^^^^^^^^

* **Jenkins (젠킨스)**

  - Java 기반의 오픈 소스 자동화 서버로, 오랫동안 CI/CD 도구의 표준처럼 여겨져 온 가장 역사가 깊은 도구다. 전 세계적으로 많은 사용자를 보유하고 있어 관련 문서와 레퍼런스가 매우 방대하고 다양하다.

  - **주요 특징**

    - 확장성 (Extensibility)
    - 자체 호스팅 (Self-Hosted)
    - 빌드 중심 아키텍처
    - 환경 호환성 및 도커 의존
    - 파이프라인 구성

  - **장점**

    - 방대한 문서와 커뮤니티
    - 엔터프라이즈급 성능
    - 폐쇄망 친화적

  - **단점**

    - 느린 배포 속도 (동기화된 작업)
    - 운영 및 유지보수 비용
    - 공유 기능의 부재
    - 플러그인 문제
    - 높은 진입 장벽

- **GitHub Actions (깃허브 액션)**

  - GitHub에서 직접 제공하는 완전 관리형(SaaS) CI/CD 서비스다. 저장소(Repository)와 파이프라인이 하나의 플랫폼에 통합되어 있다. 클라우드 기반이므로 별도의 설치가 필요 없으며, 사용자가 인프라를 확장하거나 운영하는 방법을 알 필요가 없다.

  - **주요 특징**

    - 완전 통합 및 비동기 처리
    - YAML 기반 및 코드화
    - 마켓플레이스
    - 환경 호환성

  - **장점**

    - 설정 간편화 및 효율성
    - 개발자 친화적
    - GitHub 생태계 연동

  - **단점**

    - 벤더 종속성 (Vendor Lock-in)
    - 문서 부족
    - 캐싱의 복잡성
    - 비용
    - 복잡성 한계

---------

|

b. OpenStack
~~~~~~~~

**[OpenStack이란?]**
^^^^^^^^^^^^^^^^^^

- OpenStack은 **클라우드 운영체제** 로, **데이터 센터의 컴퓨팅 자원, 스토리지 자원, 네트워크 자원의 대규모 풀을 제어** 한다. 이런 것들은 모두 웹 인터페이스로 관리된다. 관리자는 자원을 제어하며, 이용자에게 리소스를 제공할 수 있다.

  - **오픈 소스 플랫폼** : 퍼블릭 및 프라이빗 클라우드 인프라를 구축하고 운영하기 위한 다양한 서비스와 도구를 제공하는 오픈 소스 소프트웨어다.
  - **표준 제공** : 서버의 하드웨어와 운영체제는 종류가 다양하여 환경이 바뀔 때마다 전문 지식이 필요하지만, 오픈스택은 하드웨어와 OS에 관계없이 클라우드 컴퓨팅 개발의 **표준**을 제공하여 이러한 문제를 해결한다.

**1. 핵심 역할 (IaaS)**

- 오픈스택은 클라우드 컴퓨팅 기술의 핵심 구성 요소로, **IaaS(Infrastructure as a Service)** 모델을 기반으로 한다.

- 온디맨드 자원 제공
- 효율성 및 확장성 good

**2. 관리 및 도구**

- 모든 자원은 공통 인증 메커니즘을 갖춘 **API** 를 통해 관리 및 프로비저닝된다.

  - **대시보드 (Web Interface)** : 관리자에게는 자원 제어 권한을, 사용자에게는 리소스를 프로비저닝할 수 있는 기능을 웹 인터페이스를 통해 제공한다.
  - **CLI 및 SDK** : 오픈스택 CLI(Command Line Interface) 도구와 SDK를 통해 운영자는 원하는 언어(Go, Python, Ruby, Java 등 지원)로 클라우드 애플리케이션을 유연하게 생성할 수 있다.

**3. 아키텍처 및 고급 기능**

- 모듈형 프레임워크 (The OpenStack Landscape)
- **추가 기능** : 표준 IaaS 기능 외에도 오케스트레이션(Orchestration), 장애 관리(Fault Management), 서비스 관리 등의 추가 구성 요소를 제공

**4. 역사**

- **시작** : 2010년 랙스페이스 호스팅(Rackspace Hosting)과 NASA에 의해 공동으로 시작되었다.
- **목표** : 초기 목표는 모든 조직이 자체 클라우드 인프라를 쉽게 구축하고 관리할 수 있도록 하는 것이었다.
- **성장** : 전 세계 수백 개의 기업과 개발자 커뮤니티의 기여를 통해 빠르게 성장했으며, 현재 다수의 기업과 공공 기관에서 널리 사용되는 주요 오픈 소스 클라우드 플랫폼으로 자리 잡았다.


**[오픈스택의 중요성 및 이점]**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- **오픈스택의 중요성**

  - 오픈 소스
  - 유연성과 확장성
  - 다양한 클라우드 환경 지원

- **오픈스택 사용의 일반적 이점**

  - 비즈니스 민첩성 개선
  - 핵심 프로세스의 효율성 향상
  - 리소스 가용성 향상
  - 인프라에 유연성 및 적용성 추가

- **자체 클라우드 구축을 통한 이점**
  - 출시 기간 단축
  - 더 빠른 혁신
  - 규정 준수 용이
  - 벤더 종속성 탈피

**[오픈스택의 구성요소 및 작동]**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- **주요 구성 요소 (Component)**

  - **Nova** : 가상 머신(VM) 및 기타 컴퓨팅 리소스의 관리를 담당한다.
  - **Swift** : 대규모 데이터를 저장하고 관리하는 객체 스토리지 시스템이다.
  - **Neutron** : 가상 네트워킹 기능을 제공하여, 복잡한 네트워크 구성과 관리를 가능하게 한다.
  - **Ceilometer** : 오픈스택 서비스와 관련된 측저 데이터를 효과적으로 수집하고, 서비스로부터 전송된 알림을 모니터링한다. 
  - **Cinder** : VM에 영구적인 스토리지를 제공하는 블록 스토리지 서비스다.
  - **Keystone** : 인증 및 권한 부여를 관리한다.
  - **Glance** : VM 이미지의 등록, 저장, 검색 및 관리를 담당한다.
  - **Horizon** : 오픈스택의 웹 기반 대시보드로, 사용자가 클라우드 리소스를 쉽게 관리할 수 있게 한다.

- **작동 원리 및 역할**

  - **리소스 풀링 및 할당** : 물리적 리소스를 집계하여 하나의 중앙 풀(Pool)로 수집한 다음, 이 물리적 풀을 소스로 사용하여 필요한 가상 리소스를 할당한다.
  - **가상화와의 관계** : 가상화처럼 들리지만 오픈스택은 가상화 자체를 수행하지는 않는다. 오히려 기존의 가상화 기술을 사용하여 리소스를 관리한다.
  - **접근 방식** : 사용자는 셀프 서비스 포털 또는 API를 사용하여 필요한 만큼 리소스를 요청할 수 있다.
  - **NFV 수행** : 이러한 방식을 통해 오픈스택은 네트워크 기능 가상화(NFV)를 수행할 수 있다.

--------------------

|

c. zuul
~~~~~~~~

- **기본 개념**

  - **정의** : OpenStack Infrastructure 팀이 작성 및 운영하는 툴로, 실행 중인 지속적인 인프라 작업을 관리하는 오픈소스 프로젝트 게이팅 시스템(Project Gating System)이다.
  - **기존의 CI/CD와의 차이** : 일반적인 CI/CD 시스템과 비슷해 보이지만, 단순히 현재 변경 사항을 테스트하는 것이 아니라 **코드 저장소의 '미래 상태(Future State)'를 테스트** 하는 데 초점을 맞춘다.

|

- **핵심 기능: Future State 테스트 및 게이팅(Gating)**

  - **Future State 테스트** : 단순히 제안된 변경 사항 하나만 보는 것이 아니라, 여러 브랜치와 저장소에 걸쳐 있는 ‘진행 중인 변경 사항(in-flight changes)’들과 그 의존성까지 모두 포함하여 테스트한다.
  - **병합(Merge) 조건** : 프로젝트에 정의된 테스트 작업을 **반드시 통과해야만** 제안된 패치를 병합할 수 있다.

|

- **작동 원리 및 프로세스**

  - **이벤트 기반 트리거** : 다양한 코드 리뷰 시스템에서 발생하는 이벤트를 수신(Listen)하여 작동한다. 예를 들어, 패치를 **Gerrit**(코드 리뷰 시스템)의 Zuul에 푸시하면 검증 작업이 자동으로 트리거된다.
  - **작업 수행(Execute)** : 수신된 이벤트에 따라 사전에 정의된 작업을 실행한다.
  - **결과 보고(Report)** : 작업 결과를 다시 코드 리뷰 시스템으로 보고한다. 개발자는 별도의 웹 인터페이스보다 주로 코드 리뷰 시스템을 통해 Zuul과 상호작용하게 된다.

|

- **인프라 환경 및 호환성**

  - **멀티 테넌트(Multi-tenant)** : 단일 설치로 최대한 많은 프로젝트나 그룹을 동시에 서비스할 수 있으며, 프로젝트 간의 분리를 원하는 만큼 제공할 수 있다.
  - **호환성** : 광범위한 코드 리뷰 시스템과 작동하며, 서로 다른 시스템의 프로젝트를 통합하는 등 동시에 여러 시스템과 작업할 수 있다.
  - **Nodepool 통합** : 과거에는 작업을 실행할 리소스(노드) 관리를 위해 별도의 컴포넌트(Nodepool)가 필요했으나, 현재는 Zuul에 해당 기능이 통합되어 클라우드 제공자나 정적 노드 등을 관리한다.

|

- **도구 사용**

  - **Ansible 기반** : 베어메탈, VM, 쿠버네티스, 컨테이너 등 멀티 노드 환경에서의 작업 조정을 위해 **Ansible** 을 사용한다. Ansible은 배우기 쉽고 널리 알려져 있어 접근성이 좋다.
  - **유연성** : Ansible 지식이 필수적인 것은 아니다. Zuul은 쉘 스크립트나 다른 프로그램을 실행하는 작업도 지원하므로, Ansible 없이도 사용할 수 있다.

|

- **기타 참고 사항**

  - **Nodepool (노드풀)**

    - **정의** : 작업을 실행할 **리소스(노드)를 제공하고 관리** 하는 시스템이다. 클라우드 제공자나 정적으로 정의된 노드들과 연동하여 작동한다.
    - 과거에는 Zuul과 별도로 존재하는 컴포넌트였으나, **현재는 Zuul 내부에 기능이 통합** 되었다.
    - Zuul이 테스트를 하려면 서버나 컴퓨터가 필요한데, Nodepool이 이 '자원(Resource)'을 준비해서 Zuul에게 제공해 주는 역할을 한다.

  - **Docker, Kubernetes, VMs (실행 환경)**

    - Zuul이 실제 작업을 수행하는 '멀티 노드 환경'의 종류들이다.
    - Zuul은 처음부터 이러한 다양한 환경 위에서 작업을 조정하고 실행하도록 설계되었다.
    - 즉, **Zuul** 이 감독이라면, **Nodepool** 이 무대(Docker, VM 등)를 설치해주고, 그 위에서 실제 테스트가 돌아가는 구조이다.

--------------------

|

d. Q&A
~~~~~~~~

Q1. CI → CD(전달) → CD(배포) 인건지.. CI → CD(전달) or CI → CD(배포) 인건지 (두 가지 CD는 연속된 단계인가 or 각각 개별 단계인가)

- **"CI → CD(전달) OR CI → CD(배포)"** 즉, 둘 중 하나를 선택하는 개념에 가깝다
- 두 전략은 “어디까지 자동화할 것인가?”에 대한 전략의 차이
- Continuous Delivery: CI + Staging 배포 + **수동 승인** + 운영 배포
- Continuous Deployment: CI + Staging 배포 + **자동** + 운영 배포
⇒ Zuul은 지속적 배포(Deployment)에 가깝다

|

Q2. 서버 빌려주는 건 openstack이 한다고 했는데, nodepool은 왜 필요한가

- 실제 서버(vm)를 만들어내고 빌려주는 주체는  openstack이 맞다.  nodepool은 zuul과 openstack 중간의 관리자 역할을 한다.
- 속도 문제, 관리의 편리성 - nodepool은 openstack이 만드는 서버를 미리 사입해서, 창고에 쟁여두는 ‘도매상’ 역할.

  - 서버 만드는 것: openstack
  - 서버 미리 받아두고 관리: nodepool
  - 쓰는 것: zuul

- Nodepool은 테스트에 필요한 컴퓨터 자원을 전문적으로 관리하는 시스템이다.

  - 클라우드에서 그때그때 1회용 서버를 만들어내거나(동적할당, openstack등에게 명령해서 새로운 가상머신 만들어 냄), 이미 만들어져있는 고정 서버를 관리(정적할당)한다.

  - 혼자 쓰이는 게 아니라, zuul과 함께 전체 테스트 시스템을 이룬다.

|

Q3. 왜 젠킨스 안 쓰고 zuul?

- **깨진 코드가 합쳐지는 걸 원천 차단 (Project Gating)**

  - 젠킨스는 보통 코드를 합친 뒤, 빌드가 깨졌는지 확인
  - 하지만 zuul은 프로젝트 게이팅 시스템이기에, 코드가 병합되었을 때의 미래 상태를 미리 시뮬레이션 해서 테스트하고, 통과하지 못하면 아예 병합X. ⇒ 메인 브랜치의 무결성 100% 보장

- **여러 저장소가 얽힌 MSA 환경에서 테스트 불가능 (Cross - Repository Dependencies)**

  - 젠킨스는 단일 레포지토리 중심 / zuul은 여러 레포지토리 한 번에 엮어서 테스트

- **순차적 테스트의 병목 현상을 ‘추측실행’으로 해결 (Speculative Execution)**

  - 프로젝트 규모가 커지면 테스트 대기시간이 기하급수적으로 늘어난다. 젠킨스는 앞사람이 끝날 때까지 기다려야 하지만, zuul은 추측실행 알고리즘을 사용한다.

    - 앞선 변경 사항이 성공할 것이라 가정하고 병렬로 테스트 돌리기에, 논리적인 순서는 지키면서도 물리적인 시간은 획기적으로 단축시킨다.
