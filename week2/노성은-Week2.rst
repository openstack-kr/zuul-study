zuul-study week2 노성은
=====================
     
.. contents:: 목차
   :depth: 4
   :local:

CI/CD, OpenStack, Zuul 에 대한 이해
-------------------

a. CI CD
~~~~~~~~

**[CI/CD란?]**
^^^^^^^^^^^^^^^^^^

* CI/CD는 애플리케이션의 개발부터 배포까지 모든 단계를 자동화하여 , 사용자에게 빈번하고 안정적으로 서비스를 제공하는 소프트웨어 개발 전략이자 프로세스이다.

  - 코드 작성, 빌드, 테스트, 배포에 이르는 과정을 파이프라인으로 구축하여 개발 효율성과 소프트웨어 품질을 동시에 높이는 것을 목적으로 한다.
  - 개발팀이 코드 변경 사항을 더 자주, 더 빨리, 더 안정적으로 운영 환경에 적용할 수 있도록 지원한다.
  - 소프트웨어 제공 워크플로를 간소화하여 복잡성을 감소시키고, 대규모 환경에서의 효율성을 향상시킨다. 일부 개발팀은 하루에도 여러 차례 변경 사항을 배포하여, 사용자가 지속적으로 개선되는 애플리케이션을 경험할 수 있도록 한다.

* **CI - Continous Integration (지속적 통합)**
  
  - 빌드/테스트 자동화 과정. 개발자들의 코드 변경 사항을 공유 리포지토리에 정기적으로 통합하는 과정이다.
  - 소스 코드 통합 및 버전 관리 등의 개발자 작업을 보다 효율적으로 수행할 수 있도록 함으로써 소프트웨어를 보다 신속하게 운영환경에 배치할 수 있도록 해주는 사전 단계이다.
  - 여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있다.

* **CD - Continuous Deployment & Continuous Delivery (지속적 제공 및 배포 자동화)**

  - 배포 자동화 과정. CI 이후 단계에서, 코드를 실제 서비스 환경까지 자동으로 릴리즈하는 단계이다.

  - **지속적인 서비스 제공(Continuous Delivery)** : CI에서 유효성 검증이 끝난 코드들을 저장소에 자동으로 릴리스 한다. 이를 통해 운영팀은 변경된 코드들을 저장소에서 가져와서 애플리케이션에 수동으로 배포할 수 있게 된다.

    - 개발팀과 운영팀 사이의 의사소통이 좀 더 원활해질 수 있다.
    - 실제로 애플리케이션이 배포되기 전까지의 작업을 자동화한다.

  - **지속적인 배포(Continuous Deployment)** : 소프트웨어의 변경 사항이 테스트를 통과하자마자 자동으로 최종 사용자에게 배포된다.

    - 사용자의 피드백도 즉각 반영하기 쉬워진다.

* **CI/CD 파이프라인 프로세스**

  - ‘코드 커밋 → 빌드 → 테스트 → 배포’의 자동화

    1. **Code Push**: 개발자들이 개발하여 브랜치에 코드를 push 한다.
    2. **Trigger & CI:** `git push`가 감지되면 CI 서버가 Trigger되어 자동으로 Build, Test, Lint를 실행한다.
    3. **Feedback & Merge:**
        - 에러 발생 시: 개발자에게 알림이 전송되며, 개발자는 에러를 수정하여 다시 푸시한다.
        - 성공 시: 코드가 메인 브랜치에 병합(Merge)된다.
    4. 메인 브랜치 병합 후 최종 빌드 및 테스트가 완료되면, CI 파이프라인이 실행 되어 프로덕션 환경에 변경사항을 자동으로 배포한다.



**[CI/CD의 장점]**
^^^^^^^^^^^^^^^^^^^

* **기능 릴리스 가속화 및 효율성 증대**

  - 개발 프로세스 간소화: 복잡한 수동 작업을 제거하고 자동화를 통해 사람의 개입을 없애 시간과 비용을 절감한다.
  - 빈번한 배포 및 피드백: 하루에도 여러 번 배포가 가능해져 사용자 피드백을 빠르게 반영하고 기능을 개선할 수 있다.
  - 핸드오프 손실 방지
  - 경쟁 우위 확보

* **소프트웨어 품질 개선 및 테스트 자동화**

  - **탁월한 코드 품질 보장** : 입증된 자동화 테스트를 거친 코드만 배포되므로 서비스 안정성이 보장된다.
  - **신속한 오류 해결**
    - 개발자는 거의 실시간으로 코드 문제를 파악할 수 있고, 버그 수정에 드는 시간과 자원 낭비가 줄어든다.
    - 다른 프로젝트 구동 시 끝없는 수정 요청에 시달리지 않고 오로지 코딩에만 집중할 수 있다.
  - **소규모 업데이트의 이점** : 업데이트를 더 자주, 작게 도입하여 잠재적 버그와 취약성 위험을 줄이고, 이상 징후를 즉시 식별 및 수정할 수 있다.
  
  - **릴리스 지연 방지** : 2021년 깃랩 설문조사에 따르면, 릴리스 지연의 주원인은 ‘테스트’였다. CI/CD는 이를 자동화하여 상시 릴리스가 가능한 환경을 만든다.

* **개발자 경험 강화 및 업무 만족도 향상**

  - **반복 작업 제거** : 디버깅, 테스트, 검증 등 반복적이고 힘든 작업을 자동화하여 개발자의 스트레스를 줄인다.
  - **가치 있는 작업에 집중** : 수동 작업 시간을 줄여 더 중요한 문제 해결이나 가치 높은 작업에 시간을 할애할 수 있다.
  - **백로그 감소** : 시간과 비용 절감으로 여유가 생겨, 기존에 시간이 부족해 처리하지 못했던 오래된 코드(백로그)나 사소한 결함까지 수정할 수 있게 된다.
  - **팀 사기 진작** : 결과적으로 개발팀의 사기가 높아져 비즈니스 성과 향상으로 이어진다.

* **오류 격리 및 간소화된 복구 (MTTR 개선)**

  - **오류 격리** : 문제가 발생한 정확한 위치를 파악하기 어려웠던 과거와 달리, 오류를 쉽게 식별하고 격리하여 생산성을 높인다.
  - **간소화된 롤백** : 문제가 발생하면 이전 버전으로 즉시 되돌릴 수 있는 간단한 프로세스를 통해 서비스 가용성을 유지한다.
  - **MTTR(평균 해결 시간) 개선** : 문제를 신속하게 파악하고 해결함으로써 핵심 지표인 MTTR을 개선하고 비즈니스 수익에 긍정적인 영향을 미친다.

* **투명성, 책임성 및 데이터 모니터링**

  - **싱글 윈도우(Single Window)** : 통합 CI/CD 프로세스를 통해 팀 내 모든 인원과 비즈니스 이해관계자가 현황을 한눈에 파악할 수 있다.
  - **예측 가능한 마일스톤** : 개발 과정이 투명해지고 추적 가능해져 배포 일정을 자신 있게 예측하고 약속할 수 있다.
  - **지표(Metrics) 활용** : 리드 타임, 배포 빈도, 변경 실패율 등 다양한 통계 지표를 통해 코드가 실제 환경에서 어떻게 동작하는지 지속적으로 모니터링하고 피드백을 받는다.



**[CI/CD의 작동 방식]**
^^^^^^^^^^^^^^^^^^^^^^

* CI/CD는 구축 및 배포 프로세스를 자동화하여 애플리케이션 개발 주기와 소프트웨어 업데이트를 가속화한다.
* 또한, 투명하고 확장 가능한 최신 소프트웨어 개발 관행에서 더 빠른 피드백을 가능하게 하여 개발 팀과 운영 팀 간의 격차를 해소한다.
* **지속적 통합**

  - 개발자가 공유 코드 리포지토리의 변경 사항을 통합하는 방식을 자동화한다.
  - 저장소는 성공적인 빌드를 위한 소스 코드, 라이브러리, 테스트 스크립트 및 기타 리소스로 구성된다.
  - 지속적 통합을 통해 개발자는 품질 저하 없이 코드를 더 자주 제공할 수 있다.
  - 기존에 합의된 시간까지 기다려야 했던 방식에서 발생하던 코드 충돌(한 개발자의 변경이 다른 부분에 오류를 일으키는 현상) 문제를 해결하며, 여러 개발자가 동시에 작업해도 다른 사람의 코드를 손상시키지 않아 코드 릴리스가 더 빨라진다.

* **지속적 전달**

  - 지속적 통합 단계에서 검증된 코드를 프로덕션 배포에 사용할 준비가 되도록 한다.
  - CI 단계 이후, 단위, 통합, 회귀, API 안정성 테스트 등 추가 자동 테스트를 거친다.
  - 테스트를 통해 문제를 조기에 식별하고, 문제가 있는 코드를 재작업할 수 있다.
  - 검증 완료 후 서버리스 리소스, 클라우드 서버 등 인프라를 자동으로 프로비저닝한다.
  - 운영 팀이 프로덕션 환경에 애플리케이션을 **수동으로 배포**할 수 있는 상태가 된다.

* **지속적 배포**

  - 배포 단계에서 사람의 수동 개입을 제거하여 코드 자동화를 더욱 발전시킨다.
  - 자동화된 테스트 도구를 사용하여 고품질 소프트웨어를 생성한다.
  - 운영 팀의 승인을 기다리는 대신, 설정된 애플리케이션 승인 기준을 통과하면 최종 사용자에게 **자동으로 배포**된다.



**[기존의 CI/CD 툴]**
^^^^^^^^^^^^^^^^^^^^^^

* **Jenkins (젠킨스)**

  - Java 기반의 오픈 소스 자동화 서버로, 오랫동안 CI/CD 도구의 표준처럼 여겨져 온 가장 역사가 깊은 도구다. 전 세계적으로 많은 사용자를 보유하고 있어 관련 문서와 레퍼런스가 매우 방대하고 다양하다.

  - **주요 특징**

    - **확장성 (Extensibility)** : 1,800개 이상의 플러그인을 제공하여 거의 모든 개발 툴과 연동이 가능하다. 커스터마이징의 자유도가 매우 높다.
    - **자체 호스팅 (Self-Hosted)** : 사용자가 직접 서버를 설치하고 구축해야 한다. 이는 보안과 인프라 통제권을 완벽하게 가질 수 있음을 의미한다.
    - **빌드 중심 아키텍처** : GitHub 이벤트(Event)를 완벽하게 준수하기보다는, 계정 및 트리거(Trigger)를 기반으로 하는 빌드 중심의 작업을 수행한다.
    - **환경 호환성 및 도커 의존** : 환경 호환성을 확보하고 캐싱 메커니즘을 지원하기 위해 도커(Docker) 이미지 환경에서 실행해야 하는 경우가 많다.
    - **파이프라인 구성** : 주로 Groovy 언어를 기반으로 한 스크립트 방식(Scripted Pipeline)이나 선언적 방식(Declarative Pipeline)을 사용한다.

  - **장점**

    - **방대한 문서와 커뮤니티** : 무료이며 오픈 소스 커뮤니티가 매우 활발하다. 전 세계 많은 사람들이 이용하므로 문제 해결을 위한 문서가 다양하다.
    - **엔터프라이즈급 성능** : 복잡하고 정교한 대규모 파이프라인 구축에 강력하다.
    - **폐쇄망 친화적** : 온프레미스(On-premise) 환경에서의 구축이 용이하여 외부와 단절된 내부망(폐쇄망) 사용에 적합하다.

  - **단점**

    - **느린 배포 속도 (동기화된 작업)** : 작업이 동기화되어 처리되는 경향이 있어, 제품을 시장에 배포하는 데 더 많은 시간이 소요될 수 있다.
    - **운영 및 유지보수 비용** : 서버 설치, 보안 패치, 플러그인 업데이트 등을 직접 관리해야 하므로 유지보수 비용(Maintenance Overhead)이 높다. 빌드 서버를 따로 띄워야 하므로 초기 구성 자체가 어렵다.
    - **공유 기능의 부재** : 다른 사용자가 만든 워크플로우를 쉽게 가져오거나 공유할 수 있는 능력(Marketplace 등)이 부족하다.
    - **플러그인 문제** : 너무 많은 플러그인을 사용할 경우 충돌이 발생하거나 관리 지옥(Plugin Hell)에 빠질 수 있다.
    - **높은 진입 장벽** : Groovy 문법을 익혀야 하며, UI가 다소 구식이라 배우는 데 시간이 걸린다.

- **GitHub Actions (깃허브 액션)**

  - GitHub에서 직접 제공하는 완전 관리형(SaaS) CI/CD 서비스다. 저장소(Repository)와 파이프라인이 하나의 플랫폼에 통합되어 있다. 클라우드 기반이므로 별도의 설치가 필요 없으며, 사용자가 인프라를 확장하거나 운영하는 방법을 알 필요가 없다.

  - **주요 특징**

    - **완전 통합 및 비동기 처리:** GitHub 리포지토리 내에서 바로 워크플로우를 생성하고 관리한다. 모든 GitHub 이벤트에 대한 작업을 제공하며, 비동기 CI/CD를 달성할 수 있다.
    - **YAML 기반 및 코드화:** 직관적인 YAML 문법을 사용해 파이프라인을 정의한다. 많은 언어와 프레임워크를 지원하며, 코드처럼 편집, 재사용, 공유 및 분기가 가능하다.
    - **마켓플레이스:** 다른 개발자들이 만들어 둔 Action을 레고 블록처럼 가져와서 쉽게 재사용하거나 공유할 수 있다.
    - **환경 호환성:** 모든 환경과 호환된다.

  - **장점**

    - **설정 간편화 및 효율성** : 별도의 클라우드로 돌아가기 때문에 사용자가 따로 구성할 필요가 없다. 코드 푸시(Push)나 풀 리퀘스트(PR) 등의 이벤트 발생 시 즉시 실행되어 비교적 쉽게 빌드가 가능하다. 이를 통해 프로젝트를 매우 효율적으로 테스트하고 빌드할 수 있다.
    - **개발자 친화적** : 코드와 같은 저장소에서 파이프라인을 관리하므로 버전 관리가 쉽고 접근성이 높다. 개발자와 더 가깝게 실행할 수 있다.
    - **GitHub 생태계 연동** : GitHub의 보안 기능 및 이슈 트래커와 긴밀하게 연동된다. 특히 저장소를 포크(Fork)하면 작업(Action)도 자동으로 포크되기 때문에 사용이 매우 간단하다.

  - **단점**

    - **벤더 종속성 (Vendor Lock-in)** : GitHub 플랫폼에 종속되므로, 추후 다른 플랫폼(GitLab 등)으로 이전하기 어렵다.
    - **문서 부족** : 젠킨스(Jenkins)에 비해 상대적으로 문서가 부족하다.
    - **캐싱의 복잡성** : 캐싱이 필요한 경우, 자체 캐싱 메커니즘을 작성해야 한다.
    - **비용** : 공개 저장소(Public Repo)는 무료지만, 비공개 저장소(Private Repo)나 일정 사용량을 초과하면 비용이 발생한다.
    - **복잡성 한계** : Jenkins만큼의 극도로 세밀한 커스터마이징은 어려울 수 있다.

---------

b. OpenStack
~~~~~~~~

**[OpenStack이란?]**
^^^^^^^^^^^^^^^^^^

- OpenStack은 **클라우드 운영체제** 로, **데이터 센터의 컴퓨팅 자원, 스토리지 자원, 네트워크 자원의 대규모 풀을 제어** 한다. 이런 것들은 모두 웹 인터페이스로 관리된다. 관리자는 자원을 제어하며, 이용자에게 리소스를 제공할 수 있다.

  - **오픈 소스 플랫폼** : 퍼블릭 및 프라이빗 클라우드 인프라를 구축하고 운영하기 위한 다양한 서비스와 도구를 제공하는 오픈 소스 소프트웨어다.
  - **표준 제공** : 서버의 하드웨어와 운영체제는 종류가 다양하여 환경이 바뀔 때마다 전문 지식이 필요하지만, 오픈스택은 하드웨어와 OS에 관계없이 클라우드 컴퓨팅 개발의 **표준**을 제공하여 이러한 문제를 해결한다.

**1. 핵심 역할 (IaaS)**

- 오픈스택은 클라우드 컴퓨팅 기술의 핵심 구성 요소로, **IaaS(Infrastructure as a Service)** 모델을 기반으로 한다.

- **온디맨드 자원 제공** : 사용자에게 컴퓨팅 파워, 스토리지, 네트워킹 등의 리소스를 온디맨드(On-demand) 방식으로 제공한다.
- **효율성 및 확장성** : 기업이 비용 효율적이고 확장 가능한 IT 인프라를 구축하도록 지원하며, 개발자는 이를 통해 애플리케이션을 더 빠르게 개발하고 배포할 수 있다.

**2. 관리 및 도구**

- 모든 자원은 공통 인증 메커니즘을 갖춘 **API**를 통해 관리 및 프로비저닝된다.

  - **대시보드 (Web Interface)** : 관리자에게는 자원 제어 권한을, 사용자에게는 리소스를 프로비저닝할 수 있는 기능을 웹 인터페이스를 통해 제공한다.
  - **CLI 및 SDK** : 오픈스택 CLI(Command Line Interface) 도구와 SDK를 통해 운영자는 원하는 언어(Go, Python, Ruby, Java 등 지원)로 클라우드 애플리케이션을 유연하게 생성할 수 있다.

**3. 아키텍처 및 고급 기능**

- **모듈형 프레임워크 (The OpenStack Landscape)** : 오픈스택의 모듈형 구조는 사용자의 필요에 따라 구성 요소를 식별하고 배포할 수 있게 한다.
- **추가 기능** : 표준 IaaS 기능 외에도 오케스트레이션(Orchestration), 장애 관리(Fault Management), 서비스 관리 등의 추가 구성 요소를 제공한다. 이를 통해 운영자는 인프라를 맞춤 설정하고 사용자 애플리케이션의 고가용성을 보장할 수 있다.

**4. 역사**

- **시작** : 2010년 랙스페이스 호스팅(Rackspace Hosting)과 NASA에 의해 공동으로 시작되었다.
- **목표** : 초기 목표는 모든 조직이 자체 클라우드 인프라를 쉽게 구축하고 관리할 수 있도록 하는 것이었다.
- **성장** : 전 세계 수백 개의 기업과 개발자 커뮤니티의 기여를 통해 빠르게 성장했으며, 현재 다수의 기업과 공공 기관에서 널리 사용되는 주요 오픈 소스 클라우드 플랫폼으로 자리 잡았다.
